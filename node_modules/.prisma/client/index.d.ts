
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Posts
 * 
 */
export type Posts = $Result.DefaultSelection<Prisma.$PostsPayload>
/**
 * Model AspNetRoleClaims
 * 
 */
export type AspNetRoleClaims = $Result.DefaultSelection<Prisma.$AspNetRoleClaimsPayload>
/**
 * Model AspNetRoles
 * 
 */
export type AspNetRoles = $Result.DefaultSelection<Prisma.$AspNetRolesPayload>
/**
 * Model AspNetUserClaims
 * 
 */
export type AspNetUserClaims = $Result.DefaultSelection<Prisma.$AspNetUserClaimsPayload>
/**
 * Model AspNetUserLogins
 * 
 */
export type AspNetUserLogins = $Result.DefaultSelection<Prisma.$AspNetUserLoginsPayload>
/**
 * Model AspNetUserRoles
 * 
 */
export type AspNetUserRoles = $Result.DefaultSelection<Prisma.$AspNetUserRolesPayload>
/**
 * Model AspNetUserTokens
 * 
 */
export type AspNetUserTokens = $Result.DefaultSelection<Prisma.$AspNetUserTokensPayload>
/**
 * Model AspNetUsers
 * 
 */
export type AspNetUsers = $Result.DefaultSelection<Prisma.$AspNetUsersPayload>
/**
 * Model EFMigrationsHistory
 * 
 */
export type EFMigrationsHistory = $Result.DefaultSelection<Prisma.$EFMigrationsHistoryPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Posts
 * const posts = await prisma.posts.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Posts
   * const posts = await prisma.posts.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.posts`: Exposes CRUD operations for the **Posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.posts.findMany()
    * ```
    */
  get posts(): Prisma.PostsDelegate<ExtArgs>;

  /**
   * `prisma.aspNetRoleClaims`: Exposes CRUD operations for the **AspNetRoleClaims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetRoleClaims
    * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findMany()
    * ```
    */
  get aspNetRoleClaims(): Prisma.AspNetRoleClaimsDelegate<ExtArgs>;

  /**
   * `prisma.aspNetRoles`: Exposes CRUD operations for the **AspNetRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetRoles
    * const aspNetRoles = await prisma.aspNetRoles.findMany()
    * ```
    */
  get aspNetRoles(): Prisma.AspNetRolesDelegate<ExtArgs>;

  /**
   * `prisma.aspNetUserClaims`: Exposes CRUD operations for the **AspNetUserClaims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserClaims
    * const aspNetUserClaims = await prisma.aspNetUserClaims.findMany()
    * ```
    */
  get aspNetUserClaims(): Prisma.AspNetUserClaimsDelegate<ExtArgs>;

  /**
   * `prisma.aspNetUserLogins`: Exposes CRUD operations for the **AspNetUserLogins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserLogins
    * const aspNetUserLogins = await prisma.aspNetUserLogins.findMany()
    * ```
    */
  get aspNetUserLogins(): Prisma.AspNetUserLoginsDelegate<ExtArgs>;

  /**
   * `prisma.aspNetUserRoles`: Exposes CRUD operations for the **AspNetUserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserRoles
    * const aspNetUserRoles = await prisma.aspNetUserRoles.findMany()
    * ```
    */
  get aspNetUserRoles(): Prisma.AspNetUserRolesDelegate<ExtArgs>;

  /**
   * `prisma.aspNetUserTokens`: Exposes CRUD operations for the **AspNetUserTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserTokens
    * const aspNetUserTokens = await prisma.aspNetUserTokens.findMany()
    * ```
    */
  get aspNetUserTokens(): Prisma.AspNetUserTokensDelegate<ExtArgs>;

  /**
   * `prisma.aspNetUsers`: Exposes CRUD operations for the **AspNetUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUsers
    * const aspNetUsers = await prisma.aspNetUsers.findMany()
    * ```
    */
  get aspNetUsers(): Prisma.AspNetUsersDelegate<ExtArgs>;

  /**
   * `prisma.eFMigrationsHistory`: Exposes CRUD operations for the **EFMigrationsHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EFMigrationsHistories
    * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
    * ```
    */
  get eFMigrationsHistory(): Prisma.EFMigrationsHistoryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.16.1
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Posts: 'Posts',
    AspNetRoleClaims: 'AspNetRoleClaims',
    AspNetRoles: 'AspNetRoles',
    AspNetUserClaims: 'AspNetUserClaims',
    AspNetUserLogins: 'AspNetUserLogins',
    AspNetUserRoles: 'AspNetUserRoles',
    AspNetUserTokens: 'AspNetUserTokens',
    AspNetUsers: 'AspNetUsers',
    EFMigrationsHistory: 'EFMigrationsHistory'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "posts" | "aspNetRoleClaims" | "aspNetRoles" | "aspNetUserClaims" | "aspNetUserLogins" | "aspNetUserRoles" | "aspNetUserTokens" | "aspNetUsers" | "eFMigrationsHistory"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Posts: {
        payload: Prisma.$PostsPayload<ExtArgs>
        fields: Prisma.PostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          findFirst: {
            args: Prisma.PostsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          findMany: {
            args: Prisma.PostsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>[]
          }
          create: {
            args: Prisma.PostsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          createMany: {
            args: Prisma.PostsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>[]
          }
          delete: {
            args: Prisma.PostsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          update: {
            args: Prisma.PostsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          deleteMany: {
            args: Prisma.PostsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostsPayload>
          }
          aggregate: {
            args: Prisma.PostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosts>
          }
          groupBy: {
            args: Prisma.PostsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostsCountArgs<ExtArgs>
            result: $Utils.Optional<PostsCountAggregateOutputType> | number
          }
        }
      }
      AspNetRoleClaims: {
        payload: Prisma.$AspNetRoleClaimsPayload<ExtArgs>
        fields: Prisma.AspNetRoleClaimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetRoleClaimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetRoleClaimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          findFirst: {
            args: Prisma.AspNetRoleClaimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetRoleClaimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          findMany: {
            args: Prisma.AspNetRoleClaimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>[]
          }
          create: {
            args: Prisma.AspNetRoleClaimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          createMany: {
            args: Prisma.AspNetRoleClaimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspNetRoleClaimsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>[]
          }
          delete: {
            args: Prisma.AspNetRoleClaimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          update: {
            args: Prisma.AspNetRoleClaimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          deleteMany: {
            args: Prisma.AspNetRoleClaimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetRoleClaimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetRoleClaimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          aggregate: {
            args: Prisma.AspNetRoleClaimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetRoleClaims>
          }
          groupBy: {
            args: Prisma.AspNetRoleClaimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetRoleClaimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetRoleClaimsCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetRoleClaimsCountAggregateOutputType> | number
          }
        }
      }
      AspNetRoles: {
        payload: Prisma.$AspNetRolesPayload<ExtArgs>
        fields: Prisma.AspNetRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          findFirst: {
            args: Prisma.AspNetRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          findMany: {
            args: Prisma.AspNetRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>[]
          }
          create: {
            args: Prisma.AspNetRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          createMany: {
            args: Prisma.AspNetRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspNetRolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>[]
          }
          delete: {
            args: Prisma.AspNetRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          update: {
            args: Prisma.AspNetRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          deleteMany: {
            args: Prisma.AspNetRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          aggregate: {
            args: Prisma.AspNetRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetRoles>
          }
          groupBy: {
            args: Prisma.AspNetRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetRolesCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetRolesCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserClaims: {
        payload: Prisma.$AspNetUserClaimsPayload<ExtArgs>
        fields: Prisma.AspNetUserClaimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserClaimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserClaimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserClaimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserClaimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          findMany: {
            args: Prisma.AspNetUserClaimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>[]
          }
          create: {
            args: Prisma.AspNetUserClaimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          createMany: {
            args: Prisma.AspNetUserClaimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspNetUserClaimsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>[]
          }
          delete: {
            args: Prisma.AspNetUserClaimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          update: {
            args: Prisma.AspNetUserClaimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserClaimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserClaimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserClaimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserClaimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserClaims>
          }
          groupBy: {
            args: Prisma.AspNetUserClaimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserClaimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserClaimsCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserClaimsCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserLogins: {
        payload: Prisma.$AspNetUserLoginsPayload<ExtArgs>
        fields: Prisma.AspNetUserLoginsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserLoginsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserLoginsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserLoginsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserLoginsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          findMany: {
            args: Prisma.AspNetUserLoginsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>[]
          }
          create: {
            args: Prisma.AspNetUserLoginsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          createMany: {
            args: Prisma.AspNetUserLoginsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspNetUserLoginsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>[]
          }
          delete: {
            args: Prisma.AspNetUserLoginsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          update: {
            args: Prisma.AspNetUserLoginsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserLoginsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserLoginsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserLoginsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserLoginsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserLogins>
          }
          groupBy: {
            args: Prisma.AspNetUserLoginsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserLoginsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserLoginsCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserLoginsCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserRoles: {
        payload: Prisma.$AspNetUserRolesPayload<ExtArgs>
        fields: Prisma.AspNetUserRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          findMany: {
            args: Prisma.AspNetUserRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>[]
          }
          create: {
            args: Prisma.AspNetUserRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          createMany: {
            args: Prisma.AspNetUserRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspNetUserRolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>[]
          }
          delete: {
            args: Prisma.AspNetUserRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          update: {
            args: Prisma.AspNetUserRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserRoles>
          }
          groupBy: {
            args: Prisma.AspNetUserRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserRolesCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserRolesCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserTokens: {
        payload: Prisma.$AspNetUserTokensPayload<ExtArgs>
        fields: Prisma.AspNetUserTokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserTokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserTokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserTokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserTokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          findMany: {
            args: Prisma.AspNetUserTokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>[]
          }
          create: {
            args: Prisma.AspNetUserTokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          createMany: {
            args: Prisma.AspNetUserTokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspNetUserTokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>[]
          }
          delete: {
            args: Prisma.AspNetUserTokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          update: {
            args: Prisma.AspNetUserTokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserTokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserTokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserTokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserTokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserTokens>
          }
          groupBy: {
            args: Prisma.AspNetUserTokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserTokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserTokensCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserTokensCountAggregateOutputType> | number
          }
        }
      }
      AspNetUsers: {
        payload: Prisma.$AspNetUsersPayload<ExtArgs>
        fields: Prisma.AspNetUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          findFirst: {
            args: Prisma.AspNetUsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          findMany: {
            args: Prisma.AspNetUsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>[]
          }
          create: {
            args: Prisma.AspNetUsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          createMany: {
            args: Prisma.AspNetUsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspNetUsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>[]
          }
          delete: {
            args: Prisma.AspNetUsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          update: {
            args: Prisma.AspNetUsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          aggregate: {
            args: Prisma.AspNetUsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUsers>
          }
          groupBy: {
            args: Prisma.AspNetUsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUsersCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUsersCountAggregateOutputType> | number
          }
        }
      }
      EFMigrationsHistory: {
        payload: Prisma.$EFMigrationsHistoryPayload<ExtArgs>
        fields: Prisma.EFMigrationsHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EFMigrationsHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          findFirst: {
            args: Prisma.EFMigrationsHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          findMany: {
            args: Prisma.EFMigrationsHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>[]
          }
          create: {
            args: Prisma.EFMigrationsHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          createMany: {
            args: Prisma.EFMigrationsHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EFMigrationsHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>[]
          }
          delete: {
            args: Prisma.EFMigrationsHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          update: {
            args: Prisma.EFMigrationsHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          deleteMany: {
            args: Prisma.EFMigrationsHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EFMigrationsHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EFMigrationsHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          aggregate: {
            args: Prisma.EFMigrationsHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEFMigrationsHistory>
          }
          groupBy: {
            args: Prisma.EFMigrationsHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EFMigrationsHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EFMigrationsHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<EFMigrationsHistoryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AspNetRolesCountOutputType
   */

  export type AspNetRolesCountOutputType = {
    AspNetRoleClaims: number
    AspNetUserRoles: number
  }

  export type AspNetRolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoleClaims?: boolean | AspNetRolesCountOutputTypeCountAspNetRoleClaimsArgs
    AspNetUserRoles?: boolean | AspNetRolesCountOutputTypeCountAspNetUserRolesArgs
  }

  // Custom InputTypes
  /**
   * AspNetRolesCountOutputType without action
   */
  export type AspNetRolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRolesCountOutputType
     */
    select?: AspNetRolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AspNetRolesCountOutputType without action
   */
  export type AspNetRolesCountOutputTypeCountAspNetRoleClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetRoleClaimsWhereInput
  }

  /**
   * AspNetRolesCountOutputType without action
   */
  export type AspNetRolesCountOutputTypeCountAspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserRolesWhereInput
  }


  /**
   * Count Type AspNetUsersCountOutputType
   */

  export type AspNetUsersCountOutputType = {
    AspNetUserClaims: number
    AspNetUserLogins: number
    AspNetUserRoles: number
    AspNetUserTokens: number
    Posts: number
  }

  export type AspNetUsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUserClaims?: boolean | AspNetUsersCountOutputTypeCountAspNetUserClaimsArgs
    AspNetUserLogins?: boolean | AspNetUsersCountOutputTypeCountAspNetUserLoginsArgs
    AspNetUserRoles?: boolean | AspNetUsersCountOutputTypeCountAspNetUserRolesArgs
    AspNetUserTokens?: boolean | AspNetUsersCountOutputTypeCountAspNetUserTokensArgs
    Posts?: boolean | AspNetUsersCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsersCountOutputType
     */
    select?: AspNetUsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserClaimsWhereInput
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserLoginsWhereInput
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserRolesWhereInput
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserTokensWhereInput
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Posts
   */

  export type AggregatePosts = {
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  export type PostsAvgAggregateOutputType = {
    Id: number | null
    LikesCount: number | null
    ViewsCount: number | null
    CommentsCount: number | null
    UserId: number | null
  }

  export type PostsSumAggregateOutputType = {
    Id: number | null
    LikesCount: number | null
    ViewsCount: number | null
    CommentsCount: number | null
    UserId: number | null
  }

  export type PostsMinAggregateOutputType = {
    Id: number | null
    Content: string | null
    LikesCount: number | null
    ViewsCount: number | null
    CommentsCount: number | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    UserId: number | null
  }

  export type PostsMaxAggregateOutputType = {
    Id: number | null
    Content: string | null
    LikesCount: number | null
    ViewsCount: number | null
    CommentsCount: number | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
    UserId: number | null
  }

  export type PostsCountAggregateOutputType = {
    Id: number
    Content: number
    LikesCount: number
    ViewsCount: number
    CommentsCount: number
    CreatedAt: number
    UpdatedAt: number
    UserId: number
    _all: number
  }


  export type PostsAvgAggregateInputType = {
    Id?: true
    LikesCount?: true
    ViewsCount?: true
    CommentsCount?: true
    UserId?: true
  }

  export type PostsSumAggregateInputType = {
    Id?: true
    LikesCount?: true
    ViewsCount?: true
    CommentsCount?: true
    UserId?: true
  }

  export type PostsMinAggregateInputType = {
    Id?: true
    Content?: true
    LikesCount?: true
    ViewsCount?: true
    CommentsCount?: true
    CreatedAt?: true
    UpdatedAt?: true
    UserId?: true
  }

  export type PostsMaxAggregateInputType = {
    Id?: true
    Content?: true
    LikesCount?: true
    ViewsCount?: true
    CommentsCount?: true
    CreatedAt?: true
    UpdatedAt?: true
    UserId?: true
  }

  export type PostsCountAggregateInputType = {
    Id?: true
    Content?: true
    LikesCount?: true
    ViewsCount?: true
    CommentsCount?: true
    CreatedAt?: true
    UpdatedAt?: true
    UserId?: true
    _all?: true
  }

  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to aggregate.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsMaxAggregateInputType
  }

  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {
        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosts[P]>
      : GetScalarType<T[P], AggregatePosts[P]>
  }




  export type PostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostsWhereInput
    orderBy?: PostsOrderByWithAggregationInput | PostsOrderByWithAggregationInput[]
    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum
    having?: PostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsCountAggregateInputType | true
    _avg?: PostsAvgAggregateInputType
    _sum?: PostsSumAggregateInputType
    _min?: PostsMinAggregateInputType
    _max?: PostsMaxAggregateInputType
  }

  export type PostsGroupByOutputType = {
    Id: number
    Content: string
    LikesCount: number
    ViewsCount: number
    CommentsCount: number
    CreatedAt: Date
    UpdatedAt: Date
    UserId: number
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  type GetPostsGroupByPayload<T extends PostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsGroupByOutputType[P]>
        }
      >
    >


  export type PostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Content?: boolean
    LikesCount?: boolean
    ViewsCount?: boolean
    CommentsCount?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    UserId?: boolean
    User?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type PostsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Content?: boolean
    LikesCount?: boolean
    ViewsCount?: boolean
    CommentsCount?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    UserId?: boolean
    User?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type PostsSelectScalar = {
    Id?: boolean
    Content?: boolean
    LikesCount?: boolean
    ViewsCount?: boolean
    CommentsCount?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
    UserId?: boolean
  }

  export type PostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }
  export type PostsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $PostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Posts"
    objects: {
      User: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Content: string
      LikesCount: number
      ViewsCount: number
      CommentsCount: number
      CreatedAt: Date
      UpdatedAt: Date
      UserId: number
    }, ExtArgs["result"]["posts"]>
    composites: {}
  }

  type PostsGetPayload<S extends boolean | null | undefined | PostsDefaultArgs> = $Result.GetResult<Prisma.$PostsPayload, S>

  type PostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostsCountAggregateInputType | true
    }

  export interface PostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Posts'], meta: { name: 'Posts' } }
    /**
     * Find zero or one Posts that matches the filter.
     * @param {PostsFindUniqueArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostsFindUniqueArgs>(args: SelectSubset<T, PostsFindUniqueArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Posts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostsFindUniqueOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostsFindUniqueOrThrowArgs>(args: SelectSubset<T, PostsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostsFindFirstArgs>(args?: SelectSubset<T, PostsFindFirstArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindFirstOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostsFindFirstOrThrowArgs>(args?: SelectSubset<T, PostsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.posts.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.posts.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const postsWithIdOnly = await prisma.posts.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends PostsFindManyArgs>(args?: SelectSubset<T, PostsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Posts.
     * @param {PostsCreateArgs} args - Arguments to create a Posts.
     * @example
     * // Create one Posts
     * const Posts = await prisma.posts.create({
     *   data: {
     *     // ... data to create a Posts
     *   }
     * })
     * 
     */
    create<T extends PostsCreateArgs>(args: SelectSubset<T, PostsCreateArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostsCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostsCreateManyArgs>(args?: SelectSubset<T, PostsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostsCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `Id`
     * const postsWithIdOnly = await prisma.posts.createManyAndReturn({ 
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostsCreateManyAndReturnArgs>(args?: SelectSubset<T, PostsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Posts.
     * @param {PostsDeleteArgs} args - Arguments to delete one Posts.
     * @example
     * // Delete one Posts
     * const Posts = await prisma.posts.delete({
     *   where: {
     *     // ... filter to delete one Posts
     *   }
     * })
     * 
     */
    delete<T extends PostsDeleteArgs>(args: SelectSubset<T, PostsDeleteArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Posts.
     * @param {PostsUpdateArgs} args - Arguments to update one Posts.
     * @example
     * // Update one Posts
     * const posts = await prisma.posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostsUpdateArgs>(args: SelectSubset<T, PostsUpdateArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostsDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostsDeleteManyArgs>(args?: SelectSubset<T, PostsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostsUpdateManyArgs>(args: SelectSubset<T, PostsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Posts.
     * @param {PostsUpsertArgs} args - Arguments to update or create a Posts.
     * @example
     * // Update or create a Posts
     * const posts = await prisma.posts.upsert({
     *   create: {
     *     // ... data to create a Posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Posts we want to update
     *   }
     * })
     */
    upsert<T extends PostsUpsertArgs>(args: SelectSubset<T, PostsUpsertArgs<ExtArgs>>): Prisma__PostsClient<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.posts.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostsCountArgs>(
      args?: Subset<T, PostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>

    /**
     * Group by Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostsGroupByArgs['orderBy'] }
        : { orderBy?: PostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Posts model
   */
  readonly fields: PostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Posts model
   */ 
  interface PostsFieldRefs {
    readonly Id: FieldRef<"Posts", 'Int'>
    readonly Content: FieldRef<"Posts", 'String'>
    readonly LikesCount: FieldRef<"Posts", 'Int'>
    readonly ViewsCount: FieldRef<"Posts", 'Int'>
    readonly CommentsCount: FieldRef<"Posts", 'Int'>
    readonly CreatedAt: FieldRef<"Posts", 'DateTime'>
    readonly UpdatedAt: FieldRef<"Posts", 'DateTime'>
    readonly UserId: FieldRef<"Posts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Posts findUnique
   */
  export type PostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts findUniqueOrThrow
   */
  export type PostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts findFirst
   */
  export type PostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts findFirstOrThrow
   */
  export type PostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts findMany
   */
  export type PostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * Posts create
   */
  export type PostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The data needed to create a Posts.
     */
    data: XOR<PostsCreateInput, PostsUncheckedCreateInput>
  }

  /**
   * Posts createMany
   */
  export type PostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostsCreateManyInput | PostsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Posts createManyAndReturn
   */
  export type PostsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostsCreateManyInput | PostsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Posts update
   */
  export type PostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The data needed to update a Posts.
     */
    data: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
    /**
     * Choose, which Posts to update.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts updateMany
   */
  export type PostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostsWhereInput
  }

  /**
   * Posts upsert
   */
  export type PostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * The filter to search for the Posts to update in case it exists.
     */
    where: PostsWhereUniqueInput
    /**
     * In case the Posts found by the `where` argument doesn't exist, create a new Posts with this data.
     */
    create: XOR<PostsCreateInput, PostsUncheckedCreateInput>
    /**
     * In case the Posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostsUpdateInput, PostsUncheckedUpdateInput>
  }

  /**
   * Posts delete
   */
  export type PostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    /**
     * Filter which Posts to delete.
     */
    where: PostsWhereUniqueInput
  }

  /**
   * Posts deleteMany
   */
  export type PostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostsWhereInput
  }

  /**
   * Posts without action
   */
  export type PostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
  }


  /**
   * Model AspNetRoleClaims
   */

  export type AggregateAspNetRoleClaims = {
    _count: AspNetRoleClaimsCountAggregateOutputType | null
    _avg: AspNetRoleClaimsAvgAggregateOutputType | null
    _sum: AspNetRoleClaimsSumAggregateOutputType | null
    _min: AspNetRoleClaimsMinAggregateOutputType | null
    _max: AspNetRoleClaimsMaxAggregateOutputType | null
  }

  export type AspNetRoleClaimsAvgAggregateOutputType = {
    Id: number | null
    RoleId: number | null
  }

  export type AspNetRoleClaimsSumAggregateOutputType = {
    Id: number | null
    RoleId: number | null
  }

  export type AspNetRoleClaimsMinAggregateOutputType = {
    Id: number | null
    RoleId: number | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetRoleClaimsMaxAggregateOutputType = {
    Id: number | null
    RoleId: number | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetRoleClaimsCountAggregateOutputType = {
    Id: number
    RoleId: number
    ClaimType: number
    ClaimValue: number
    _all: number
  }


  export type AspNetRoleClaimsAvgAggregateInputType = {
    Id?: true
    RoleId?: true
  }

  export type AspNetRoleClaimsSumAggregateInputType = {
    Id?: true
    RoleId?: true
  }

  export type AspNetRoleClaimsMinAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetRoleClaimsMaxAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetRoleClaimsCountAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
    _all?: true
  }

  export type AspNetRoleClaimsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoleClaims to aggregate.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetRoleClaims
    **/
    _count?: true | AspNetRoleClaimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetRoleClaimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetRoleClaimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetRoleClaimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetRoleClaimsMaxAggregateInputType
  }

  export type GetAspNetRoleClaimsAggregateType<T extends AspNetRoleClaimsAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetRoleClaims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetRoleClaims[P]>
      : GetScalarType<T[P], AggregateAspNetRoleClaims[P]>
  }




  export type AspNetRoleClaimsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetRoleClaimsWhereInput
    orderBy?: AspNetRoleClaimsOrderByWithAggregationInput | AspNetRoleClaimsOrderByWithAggregationInput[]
    by: AspNetRoleClaimsScalarFieldEnum[] | AspNetRoleClaimsScalarFieldEnum
    having?: AspNetRoleClaimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetRoleClaimsCountAggregateInputType | true
    _avg?: AspNetRoleClaimsAvgAggregateInputType
    _sum?: AspNetRoleClaimsSumAggregateInputType
    _min?: AspNetRoleClaimsMinAggregateInputType
    _max?: AspNetRoleClaimsMaxAggregateInputType
  }

  export type AspNetRoleClaimsGroupByOutputType = {
    Id: number
    RoleId: number
    ClaimType: string | null
    ClaimValue: string | null
    _count: AspNetRoleClaimsCountAggregateOutputType | null
    _avg: AspNetRoleClaimsAvgAggregateOutputType | null
    _sum: AspNetRoleClaimsSumAggregateOutputType | null
    _min: AspNetRoleClaimsMinAggregateOutputType | null
    _max: AspNetRoleClaimsMaxAggregateOutputType | null
  }

  type GetAspNetRoleClaimsGroupByPayload<T extends AspNetRoleClaimsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetRoleClaimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetRoleClaimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetRoleClaimsGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetRoleClaimsGroupByOutputType[P]>
        }
      >
    >


  export type AspNetRoleClaimsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    RoleId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetRoleClaims"]>

  export type AspNetRoleClaimsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    RoleId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetRoleClaims"]>

  export type AspNetRoleClaimsSelectScalar = {
    Id?: boolean
    RoleId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
  }

  export type AspNetRoleClaimsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
  }
  export type AspNetRoleClaimsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
  }

  export type $AspNetRoleClaimsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetRoleClaims"
    objects: {
      AspNetRoles: Prisma.$AspNetRolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      RoleId: number
      ClaimType: string | null
      ClaimValue: string | null
    }, ExtArgs["result"]["aspNetRoleClaims"]>
    composites: {}
  }

  type AspNetRoleClaimsGetPayload<S extends boolean | null | undefined | AspNetRoleClaimsDefaultArgs> = $Result.GetResult<Prisma.$AspNetRoleClaimsPayload, S>

  type AspNetRoleClaimsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AspNetRoleClaimsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AspNetRoleClaimsCountAggregateInputType | true
    }

  export interface AspNetRoleClaimsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetRoleClaims'], meta: { name: 'AspNetRoleClaims' } }
    /**
     * Find zero or one AspNetRoleClaims that matches the filter.
     * @param {AspNetRoleClaimsFindUniqueArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetRoleClaimsFindUniqueArgs>(args: SelectSubset<T, AspNetRoleClaimsFindUniqueArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AspNetRoleClaims that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AspNetRoleClaimsFindUniqueOrThrowArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetRoleClaimsFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetRoleClaimsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AspNetRoleClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsFindFirstArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetRoleClaimsFindFirstArgs>(args?: SelectSubset<T, AspNetRoleClaimsFindFirstArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AspNetRoleClaims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsFindFirstOrThrowArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetRoleClaimsFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetRoleClaimsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AspNetRoleClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findMany()
     * 
     * // Get first 10 AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetRoleClaimsWithIdOnly = await prisma.aspNetRoleClaims.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetRoleClaimsFindManyArgs>(args?: SelectSubset<T, AspNetRoleClaimsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AspNetRoleClaims.
     * @param {AspNetRoleClaimsCreateArgs} args - Arguments to create a AspNetRoleClaims.
     * @example
     * // Create one AspNetRoleClaims
     * const AspNetRoleClaims = await prisma.aspNetRoleClaims.create({
     *   data: {
     *     // ... data to create a AspNetRoleClaims
     *   }
     * })
     * 
     */
    create<T extends AspNetRoleClaimsCreateArgs>(args: SelectSubset<T, AspNetRoleClaimsCreateArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AspNetRoleClaims.
     * @param {AspNetRoleClaimsCreateManyArgs} args - Arguments to create many AspNetRoleClaims.
     * @example
     * // Create many AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetRoleClaimsCreateManyArgs>(args?: SelectSubset<T, AspNetRoleClaimsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspNetRoleClaims and returns the data saved in the database.
     * @param {AspNetRoleClaimsCreateManyAndReturnArgs} args - Arguments to create many AspNetRoleClaims.
     * @example
     * // Create many AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspNetRoleClaims and only return the `Id`
     * const aspNetRoleClaimsWithIdOnly = await prisma.aspNetRoleClaims.createManyAndReturn({ 
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspNetRoleClaimsCreateManyAndReturnArgs>(args?: SelectSubset<T, AspNetRoleClaimsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AspNetRoleClaims.
     * @param {AspNetRoleClaimsDeleteArgs} args - Arguments to delete one AspNetRoleClaims.
     * @example
     * // Delete one AspNetRoleClaims
     * const AspNetRoleClaims = await prisma.aspNetRoleClaims.delete({
     *   where: {
     *     // ... filter to delete one AspNetRoleClaims
     *   }
     * })
     * 
     */
    delete<T extends AspNetRoleClaimsDeleteArgs>(args: SelectSubset<T, AspNetRoleClaimsDeleteArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AspNetRoleClaims.
     * @param {AspNetRoleClaimsUpdateArgs} args - Arguments to update one AspNetRoleClaims.
     * @example
     * // Update one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetRoleClaimsUpdateArgs>(args: SelectSubset<T, AspNetRoleClaimsUpdateArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AspNetRoleClaims.
     * @param {AspNetRoleClaimsDeleteManyArgs} args - Arguments to filter AspNetRoleClaims to delete.
     * @example
     * // Delete a few AspNetRoleClaims
     * const { count } = await prisma.aspNetRoleClaims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetRoleClaimsDeleteManyArgs>(args?: SelectSubset<T, AspNetRoleClaimsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetRoleClaimsUpdateManyArgs>(args: SelectSubset<T, AspNetRoleClaimsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetRoleClaims.
     * @param {AspNetRoleClaimsUpsertArgs} args - Arguments to update or create a AspNetRoleClaims.
     * @example
     * // Update or create a AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.upsert({
     *   create: {
     *     // ... data to create a AspNetRoleClaims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetRoleClaims we want to update
     *   }
     * })
     */
    upsert<T extends AspNetRoleClaimsUpsertArgs>(args: SelectSubset<T, AspNetRoleClaimsUpsertArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsCountArgs} args - Arguments to filter AspNetRoleClaims to count.
     * @example
     * // Count the number of AspNetRoleClaims
     * const count = await prisma.aspNetRoleClaims.count({
     *   where: {
     *     // ... the filter for the AspNetRoleClaims we want to count
     *   }
     * })
    **/
    count<T extends AspNetRoleClaimsCountArgs>(
      args?: Subset<T, AspNetRoleClaimsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetRoleClaimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetRoleClaimsAggregateArgs>(args: Subset<T, AspNetRoleClaimsAggregateArgs>): Prisma.PrismaPromise<GetAspNetRoleClaimsAggregateType<T>>

    /**
     * Group by AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetRoleClaimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetRoleClaimsGroupByArgs['orderBy'] }
        : { orderBy?: AspNetRoleClaimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetRoleClaimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetRoleClaimsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetRoleClaims model
   */
  readonly fields: AspNetRoleClaimsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetRoleClaims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetRoleClaimsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetRoles<T extends AspNetRolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRolesDefaultArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetRoleClaims model
   */ 
  interface AspNetRoleClaimsFieldRefs {
    readonly Id: FieldRef<"AspNetRoleClaims", 'Int'>
    readonly RoleId: FieldRef<"AspNetRoleClaims", 'Int'>
    readonly ClaimType: FieldRef<"AspNetRoleClaims", 'String'>
    readonly ClaimValue: FieldRef<"AspNetRoleClaims", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetRoleClaims findUnique
   */
  export type AspNetRoleClaimsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims findUniqueOrThrow
   */
  export type AspNetRoleClaimsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims findFirst
   */
  export type AspNetRoleClaimsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoleClaims.
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoleClaims.
     */
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoleClaims findFirstOrThrow
   */
  export type AspNetRoleClaimsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoleClaims.
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoleClaims.
     */
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoleClaims findMany
   */
  export type AspNetRoleClaimsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetRoleClaims.
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoleClaims create
   */
  export type AspNetRoleClaimsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetRoleClaims.
     */
    data: XOR<AspNetRoleClaimsCreateInput, AspNetRoleClaimsUncheckedCreateInput>
  }

  /**
   * AspNetRoleClaims createMany
   */
  export type AspNetRoleClaimsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetRoleClaims.
     */
    data: AspNetRoleClaimsCreateManyInput | AspNetRoleClaimsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetRoleClaims createManyAndReturn
   */
  export type AspNetRoleClaimsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AspNetRoleClaims.
     */
    data: AspNetRoleClaimsCreateManyInput | AspNetRoleClaimsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AspNetRoleClaims update
   */
  export type AspNetRoleClaimsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetRoleClaims.
     */
    data: XOR<AspNetRoleClaimsUpdateInput, AspNetRoleClaimsUncheckedUpdateInput>
    /**
     * Choose, which AspNetRoleClaims to update.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims updateMany
   */
  export type AspNetRoleClaimsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetRoleClaims.
     */
    data: XOR<AspNetRoleClaimsUpdateManyMutationInput, AspNetRoleClaimsUncheckedUpdateManyInput>
    /**
     * Filter which AspNetRoleClaims to update
     */
    where?: AspNetRoleClaimsWhereInput
  }

  /**
   * AspNetRoleClaims upsert
   */
  export type AspNetRoleClaimsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetRoleClaims to update in case it exists.
     */
    where: AspNetRoleClaimsWhereUniqueInput
    /**
     * In case the AspNetRoleClaims found by the `where` argument doesn't exist, create a new AspNetRoleClaims with this data.
     */
    create: XOR<AspNetRoleClaimsCreateInput, AspNetRoleClaimsUncheckedCreateInput>
    /**
     * In case the AspNetRoleClaims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetRoleClaimsUpdateInput, AspNetRoleClaimsUncheckedUpdateInput>
  }

  /**
   * AspNetRoleClaims delete
   */
  export type AspNetRoleClaimsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter which AspNetRoleClaims to delete.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims deleteMany
   */
  export type AspNetRoleClaimsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoleClaims to delete
     */
    where?: AspNetRoleClaimsWhereInput
  }

  /**
   * AspNetRoleClaims without action
   */
  export type AspNetRoleClaimsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
  }


  /**
   * Model AspNetRoles
   */

  export type AggregateAspNetRoles = {
    _count: AspNetRolesCountAggregateOutputType | null
    _avg: AspNetRolesAvgAggregateOutputType | null
    _sum: AspNetRolesSumAggregateOutputType | null
    _min: AspNetRolesMinAggregateOutputType | null
    _max: AspNetRolesMaxAggregateOutputType | null
  }

  export type AspNetRolesAvgAggregateOutputType = {
    Id: number | null
  }

  export type AspNetRolesSumAggregateOutputType = {
    Id: number | null
  }

  export type AspNetRolesMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
  }

  export type AspNetRolesMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
  }

  export type AspNetRolesCountAggregateOutputType = {
    Id: number
    Name: number
    NormalizedName: number
    ConcurrencyStamp: number
    _all: number
  }


  export type AspNetRolesAvgAggregateInputType = {
    Id?: true
  }

  export type AspNetRolesSumAggregateInputType = {
    Id?: true
  }

  export type AspNetRolesMinAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
  }

  export type AspNetRolesMaxAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
  }

  export type AspNetRolesCountAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
    _all?: true
  }

  export type AspNetRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoles to aggregate.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetRoles
    **/
    _count?: true | AspNetRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetRolesMaxAggregateInputType
  }

  export type GetAspNetRolesAggregateType<T extends AspNetRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetRoles[P]>
      : GetScalarType<T[P], AggregateAspNetRoles[P]>
  }




  export type AspNetRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetRolesWhereInput
    orderBy?: AspNetRolesOrderByWithAggregationInput | AspNetRolesOrderByWithAggregationInput[]
    by: AspNetRolesScalarFieldEnum[] | AspNetRolesScalarFieldEnum
    having?: AspNetRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetRolesCountAggregateInputType | true
    _avg?: AspNetRolesAvgAggregateInputType
    _sum?: AspNetRolesSumAggregateInputType
    _min?: AspNetRolesMinAggregateInputType
    _max?: AspNetRolesMaxAggregateInputType
  }

  export type AspNetRolesGroupByOutputType = {
    Id: number
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
    _count: AspNetRolesCountAggregateOutputType | null
    _avg: AspNetRolesAvgAggregateOutputType | null
    _sum: AspNetRolesSumAggregateOutputType | null
    _min: AspNetRolesMinAggregateOutputType | null
    _max: AspNetRolesMaxAggregateOutputType | null
  }

  type GetAspNetRolesGroupByPayload<T extends AspNetRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetRolesGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetRolesGroupByOutputType[P]>
        }
      >
    >


  export type AspNetRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    NormalizedName?: boolean
    ConcurrencyStamp?: boolean
    AspNetRoleClaims?: boolean | AspNetRoles$AspNetRoleClaimsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetRoles$AspNetUserRolesArgs<ExtArgs>
    _count?: boolean | AspNetRolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetRoles"]>

  export type AspNetRolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    NormalizedName?: boolean
    ConcurrencyStamp?: boolean
  }, ExtArgs["result"]["aspNetRoles"]>

  export type AspNetRolesSelectScalar = {
    Id?: boolean
    Name?: boolean
    NormalizedName?: boolean
    ConcurrencyStamp?: boolean
  }

  export type AspNetRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoleClaims?: boolean | AspNetRoles$AspNetRoleClaimsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetRoles$AspNetUserRolesArgs<ExtArgs>
    _count?: boolean | AspNetRolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AspNetRolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AspNetRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetRoles"
    objects: {
      AspNetRoleClaims: Prisma.$AspNetRoleClaimsPayload<ExtArgs>[]
      AspNetUserRoles: Prisma.$AspNetUserRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Name: string | null
      NormalizedName: string | null
      ConcurrencyStamp: string | null
    }, ExtArgs["result"]["aspNetRoles"]>
    composites: {}
  }

  type AspNetRolesGetPayload<S extends boolean | null | undefined | AspNetRolesDefaultArgs> = $Result.GetResult<Prisma.$AspNetRolesPayload, S>

  type AspNetRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AspNetRolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AspNetRolesCountAggregateInputType | true
    }

  export interface AspNetRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetRoles'], meta: { name: 'AspNetRoles' } }
    /**
     * Find zero or one AspNetRoles that matches the filter.
     * @param {AspNetRolesFindUniqueArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetRolesFindUniqueArgs>(args: SelectSubset<T, AspNetRolesFindUniqueArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AspNetRoles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AspNetRolesFindUniqueOrThrowArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AspNetRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesFindFirstArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetRolesFindFirstArgs>(args?: SelectSubset<T, AspNetRolesFindFirstArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AspNetRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesFindFirstOrThrowArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AspNetRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findMany()
     * 
     * // Get first 10 AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetRolesWithIdOnly = await prisma.aspNetRoles.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetRolesFindManyArgs>(args?: SelectSubset<T, AspNetRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AspNetRoles.
     * @param {AspNetRolesCreateArgs} args - Arguments to create a AspNetRoles.
     * @example
     * // Create one AspNetRoles
     * const AspNetRoles = await prisma.aspNetRoles.create({
     *   data: {
     *     // ... data to create a AspNetRoles
     *   }
     * })
     * 
     */
    create<T extends AspNetRolesCreateArgs>(args: SelectSubset<T, AspNetRolesCreateArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AspNetRoles.
     * @param {AspNetRolesCreateManyArgs} args - Arguments to create many AspNetRoles.
     * @example
     * // Create many AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetRolesCreateManyArgs>(args?: SelectSubset<T, AspNetRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspNetRoles and returns the data saved in the database.
     * @param {AspNetRolesCreateManyAndReturnArgs} args - Arguments to create many AspNetRoles.
     * @example
     * // Create many AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspNetRoles and only return the `Id`
     * const aspNetRolesWithIdOnly = await prisma.aspNetRoles.createManyAndReturn({ 
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspNetRolesCreateManyAndReturnArgs>(args?: SelectSubset<T, AspNetRolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AspNetRoles.
     * @param {AspNetRolesDeleteArgs} args - Arguments to delete one AspNetRoles.
     * @example
     * // Delete one AspNetRoles
     * const AspNetRoles = await prisma.aspNetRoles.delete({
     *   where: {
     *     // ... filter to delete one AspNetRoles
     *   }
     * })
     * 
     */
    delete<T extends AspNetRolesDeleteArgs>(args: SelectSubset<T, AspNetRolesDeleteArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AspNetRoles.
     * @param {AspNetRolesUpdateArgs} args - Arguments to update one AspNetRoles.
     * @example
     * // Update one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetRolesUpdateArgs>(args: SelectSubset<T, AspNetRolesUpdateArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AspNetRoles.
     * @param {AspNetRolesDeleteManyArgs} args - Arguments to filter AspNetRoles to delete.
     * @example
     * // Delete a few AspNetRoles
     * const { count } = await prisma.aspNetRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetRolesDeleteManyArgs>(args?: SelectSubset<T, AspNetRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetRolesUpdateManyArgs>(args: SelectSubset<T, AspNetRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetRoles.
     * @param {AspNetRolesUpsertArgs} args - Arguments to update or create a AspNetRoles.
     * @example
     * // Update or create a AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.upsert({
     *   create: {
     *     // ... data to create a AspNetRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetRoles we want to update
     *   }
     * })
     */
    upsert<T extends AspNetRolesUpsertArgs>(args: SelectSubset<T, AspNetRolesUpsertArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesCountArgs} args - Arguments to filter AspNetRoles to count.
     * @example
     * // Count the number of AspNetRoles
     * const count = await prisma.aspNetRoles.count({
     *   where: {
     *     // ... the filter for the AspNetRoles we want to count
     *   }
     * })
    **/
    count<T extends AspNetRolesCountArgs>(
      args?: Subset<T, AspNetRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetRolesAggregateArgs>(args: Subset<T, AspNetRolesAggregateArgs>): Prisma.PrismaPromise<GetAspNetRolesAggregateType<T>>

    /**
     * Group by AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetRolesGroupByArgs['orderBy'] }
        : { orderBy?: AspNetRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetRoles model
   */
  readonly fields: AspNetRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetRoleClaims<T extends AspNetRoles$AspNetRoleClaimsArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRoles$AspNetRoleClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findMany"> | Null>
    AspNetUserRoles<T extends AspNetRoles$AspNetUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRoles$AspNetUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetRoles model
   */ 
  interface AspNetRolesFieldRefs {
    readonly Id: FieldRef<"AspNetRoles", 'Int'>
    readonly Name: FieldRef<"AspNetRoles", 'String'>
    readonly NormalizedName: FieldRef<"AspNetRoles", 'String'>
    readonly ConcurrencyStamp: FieldRef<"AspNetRoles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetRoles findUnique
   */
  export type AspNetRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles findUniqueOrThrow
   */
  export type AspNetRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles findFirst
   */
  export type AspNetRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoles.
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoles.
     */
    distinct?: AspNetRolesScalarFieldEnum | AspNetRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles findFirstOrThrow
   */
  export type AspNetRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoles.
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoles.
     */
    distinct?: AspNetRolesScalarFieldEnum | AspNetRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles findMany
   */
  export type AspNetRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetRoles.
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    distinct?: AspNetRolesScalarFieldEnum | AspNetRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles create
   */
  export type AspNetRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetRoles.
     */
    data?: XOR<AspNetRolesCreateInput, AspNetRolesUncheckedCreateInput>
  }

  /**
   * AspNetRoles createMany
   */
  export type AspNetRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetRoles.
     */
    data: AspNetRolesCreateManyInput | AspNetRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetRoles createManyAndReturn
   */
  export type AspNetRolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AspNetRoles.
     */
    data: AspNetRolesCreateManyInput | AspNetRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetRoles update
   */
  export type AspNetRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetRoles.
     */
    data: XOR<AspNetRolesUpdateInput, AspNetRolesUncheckedUpdateInput>
    /**
     * Choose, which AspNetRoles to update.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles updateMany
   */
  export type AspNetRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetRoles.
     */
    data: XOR<AspNetRolesUpdateManyMutationInput, AspNetRolesUncheckedUpdateManyInput>
    /**
     * Filter which AspNetRoles to update
     */
    where?: AspNetRolesWhereInput
  }

  /**
   * AspNetRoles upsert
   */
  export type AspNetRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetRoles to update in case it exists.
     */
    where: AspNetRolesWhereUniqueInput
    /**
     * In case the AspNetRoles found by the `where` argument doesn't exist, create a new AspNetRoles with this data.
     */
    create: XOR<AspNetRolesCreateInput, AspNetRolesUncheckedCreateInput>
    /**
     * In case the AspNetRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetRolesUpdateInput, AspNetRolesUncheckedUpdateInput>
  }

  /**
   * AspNetRoles delete
   */
  export type AspNetRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter which AspNetRoles to delete.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles deleteMany
   */
  export type AspNetRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoles to delete
     */
    where?: AspNetRolesWhereInput
  }

  /**
   * AspNetRoles.AspNetRoleClaims
   */
  export type AspNetRoles$AspNetRoleClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    where?: AspNetRoleClaimsWhereInput
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    cursor?: AspNetRoleClaimsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoles.AspNetUserRoles
   */
  export type AspNetRoles$AspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    where?: AspNetUserRolesWhereInput
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    cursor?: AspNetUserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles without action
   */
  export type AspNetRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserClaims
   */

  export type AggregateAspNetUserClaims = {
    _count: AspNetUserClaimsCountAggregateOutputType | null
    _avg: AspNetUserClaimsAvgAggregateOutputType | null
    _sum: AspNetUserClaimsSumAggregateOutputType | null
    _min: AspNetUserClaimsMinAggregateOutputType | null
    _max: AspNetUserClaimsMaxAggregateOutputType | null
  }

  export type AspNetUserClaimsAvgAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type AspNetUserClaimsSumAggregateOutputType = {
    Id: number | null
    UserId: number | null
  }

  export type AspNetUserClaimsMinAggregateOutputType = {
    Id: number | null
    UserId: number | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetUserClaimsMaxAggregateOutputType = {
    Id: number | null
    UserId: number | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetUserClaimsCountAggregateOutputType = {
    Id: number
    UserId: number
    ClaimType: number
    ClaimValue: number
    _all: number
  }


  export type AspNetUserClaimsAvgAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type AspNetUserClaimsSumAggregateInputType = {
    Id?: true
    UserId?: true
  }

  export type AspNetUserClaimsMinAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetUserClaimsMaxAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetUserClaimsCountAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
    _all?: true
  }

  export type AspNetUserClaimsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserClaims to aggregate.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserClaims
    **/
    _count?: true | AspNetUserClaimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetUserClaimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetUserClaimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserClaimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserClaimsMaxAggregateInputType
  }

  export type GetAspNetUserClaimsAggregateType<T extends AspNetUserClaimsAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserClaims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserClaims[P]>
      : GetScalarType<T[P], AggregateAspNetUserClaims[P]>
  }




  export type AspNetUserClaimsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserClaimsWhereInput
    orderBy?: AspNetUserClaimsOrderByWithAggregationInput | AspNetUserClaimsOrderByWithAggregationInput[]
    by: AspNetUserClaimsScalarFieldEnum[] | AspNetUserClaimsScalarFieldEnum
    having?: AspNetUserClaimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserClaimsCountAggregateInputType | true
    _avg?: AspNetUserClaimsAvgAggregateInputType
    _sum?: AspNetUserClaimsSumAggregateInputType
    _min?: AspNetUserClaimsMinAggregateInputType
    _max?: AspNetUserClaimsMaxAggregateInputType
  }

  export type AspNetUserClaimsGroupByOutputType = {
    Id: number
    UserId: number
    ClaimType: string | null
    ClaimValue: string | null
    _count: AspNetUserClaimsCountAggregateOutputType | null
    _avg: AspNetUserClaimsAvgAggregateOutputType | null
    _sum: AspNetUserClaimsSumAggregateOutputType | null
    _min: AspNetUserClaimsMinAggregateOutputType | null
    _max: AspNetUserClaimsMaxAggregateOutputType | null
  }

  type GetAspNetUserClaimsGroupByPayload<T extends AspNetUserClaimsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserClaimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserClaimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserClaimsGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserClaimsGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserClaimsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserClaims"]>

  export type AspNetUserClaimsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserClaims"]>

  export type AspNetUserClaimsSelectScalar = {
    Id?: boolean
    UserId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
  }

  export type AspNetUserClaimsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }
  export type AspNetUserClaimsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserClaimsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserClaims"
    objects: {
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UserId: number
      ClaimType: string | null
      ClaimValue: string | null
    }, ExtArgs["result"]["aspNetUserClaims"]>
    composites: {}
  }

  type AspNetUserClaimsGetPayload<S extends boolean | null | undefined | AspNetUserClaimsDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserClaimsPayload, S>

  type AspNetUserClaimsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AspNetUserClaimsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AspNetUserClaimsCountAggregateInputType | true
    }

  export interface AspNetUserClaimsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserClaims'], meta: { name: 'AspNetUserClaims' } }
    /**
     * Find zero or one AspNetUserClaims that matches the filter.
     * @param {AspNetUserClaimsFindUniqueArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserClaimsFindUniqueArgs>(args: SelectSubset<T, AspNetUserClaimsFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AspNetUserClaims that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AspNetUserClaimsFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserClaimsFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserClaimsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AspNetUserClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsFindFirstArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserClaimsFindFirstArgs>(args?: SelectSubset<T, AspNetUserClaimsFindFirstArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AspNetUserClaims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsFindFirstOrThrowArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserClaimsFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserClaimsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AspNetUserClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findMany()
     * 
     * // Get first 10 AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetUserClaimsWithIdOnly = await prisma.aspNetUserClaims.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetUserClaimsFindManyArgs>(args?: SelectSubset<T, AspNetUserClaimsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AspNetUserClaims.
     * @param {AspNetUserClaimsCreateArgs} args - Arguments to create a AspNetUserClaims.
     * @example
     * // Create one AspNetUserClaims
     * const AspNetUserClaims = await prisma.aspNetUserClaims.create({
     *   data: {
     *     // ... data to create a AspNetUserClaims
     *   }
     * })
     * 
     */
    create<T extends AspNetUserClaimsCreateArgs>(args: SelectSubset<T, AspNetUserClaimsCreateArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AspNetUserClaims.
     * @param {AspNetUserClaimsCreateManyArgs} args - Arguments to create many AspNetUserClaims.
     * @example
     * // Create many AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserClaimsCreateManyArgs>(args?: SelectSubset<T, AspNetUserClaimsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspNetUserClaims and returns the data saved in the database.
     * @param {AspNetUserClaimsCreateManyAndReturnArgs} args - Arguments to create many AspNetUserClaims.
     * @example
     * // Create many AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspNetUserClaims and only return the `Id`
     * const aspNetUserClaimsWithIdOnly = await prisma.aspNetUserClaims.createManyAndReturn({ 
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspNetUserClaimsCreateManyAndReturnArgs>(args?: SelectSubset<T, AspNetUserClaimsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AspNetUserClaims.
     * @param {AspNetUserClaimsDeleteArgs} args - Arguments to delete one AspNetUserClaims.
     * @example
     * // Delete one AspNetUserClaims
     * const AspNetUserClaims = await prisma.aspNetUserClaims.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserClaims
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserClaimsDeleteArgs>(args: SelectSubset<T, AspNetUserClaimsDeleteArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AspNetUserClaims.
     * @param {AspNetUserClaimsUpdateArgs} args - Arguments to update one AspNetUserClaims.
     * @example
     * // Update one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserClaimsUpdateArgs>(args: SelectSubset<T, AspNetUserClaimsUpdateArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AspNetUserClaims.
     * @param {AspNetUserClaimsDeleteManyArgs} args - Arguments to filter AspNetUserClaims to delete.
     * @example
     * // Delete a few AspNetUserClaims
     * const { count } = await prisma.aspNetUserClaims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserClaimsDeleteManyArgs>(args?: SelectSubset<T, AspNetUserClaimsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserClaimsUpdateManyArgs>(args: SelectSubset<T, AspNetUserClaimsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserClaims.
     * @param {AspNetUserClaimsUpsertArgs} args - Arguments to update or create a AspNetUserClaims.
     * @example
     * // Update or create a AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.upsert({
     *   create: {
     *     // ... data to create a AspNetUserClaims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserClaims we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserClaimsUpsertArgs>(args: SelectSubset<T, AspNetUserClaimsUpsertArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsCountArgs} args - Arguments to filter AspNetUserClaims to count.
     * @example
     * // Count the number of AspNetUserClaims
     * const count = await prisma.aspNetUserClaims.count({
     *   where: {
     *     // ... the filter for the AspNetUserClaims we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserClaimsCountArgs>(
      args?: Subset<T, AspNetUserClaimsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserClaimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserClaimsAggregateArgs>(args: Subset<T, AspNetUserClaimsAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserClaimsAggregateType<T>>

    /**
     * Group by AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserClaimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserClaimsGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserClaimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserClaimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserClaimsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserClaims model
   */
  readonly fields: AspNetUserClaimsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserClaims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserClaimsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserClaims model
   */ 
  interface AspNetUserClaimsFieldRefs {
    readonly Id: FieldRef<"AspNetUserClaims", 'Int'>
    readonly UserId: FieldRef<"AspNetUserClaims", 'Int'>
    readonly ClaimType: FieldRef<"AspNetUserClaims", 'String'>
    readonly ClaimValue: FieldRef<"AspNetUserClaims", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserClaims findUnique
   */
  export type AspNetUserClaimsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims findUniqueOrThrow
   */
  export type AspNetUserClaimsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims findFirst
   */
  export type AspNetUserClaimsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserClaims.
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserClaims.
     */
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUserClaims findFirstOrThrow
   */
  export type AspNetUserClaimsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserClaims.
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserClaims.
     */
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUserClaims findMany
   */
  export type AspNetUserClaimsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserClaims.
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUserClaims create
   */
  export type AspNetUserClaimsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserClaims.
     */
    data: XOR<AspNetUserClaimsCreateInput, AspNetUserClaimsUncheckedCreateInput>
  }

  /**
   * AspNetUserClaims createMany
   */
  export type AspNetUserClaimsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserClaims.
     */
    data: AspNetUserClaimsCreateManyInput | AspNetUserClaimsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetUserClaims createManyAndReturn
   */
  export type AspNetUserClaimsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AspNetUserClaims.
     */
    data: AspNetUserClaimsCreateManyInput | AspNetUserClaimsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AspNetUserClaims update
   */
  export type AspNetUserClaimsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserClaims.
     */
    data: XOR<AspNetUserClaimsUpdateInput, AspNetUserClaimsUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserClaims to update.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims updateMany
   */
  export type AspNetUserClaimsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserClaims.
     */
    data: XOR<AspNetUserClaimsUpdateManyMutationInput, AspNetUserClaimsUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserClaims to update
     */
    where?: AspNetUserClaimsWhereInput
  }

  /**
   * AspNetUserClaims upsert
   */
  export type AspNetUserClaimsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserClaims to update in case it exists.
     */
    where: AspNetUserClaimsWhereUniqueInput
    /**
     * In case the AspNetUserClaims found by the `where` argument doesn't exist, create a new AspNetUserClaims with this data.
     */
    create: XOR<AspNetUserClaimsCreateInput, AspNetUserClaimsUncheckedCreateInput>
    /**
     * In case the AspNetUserClaims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserClaimsUpdateInput, AspNetUserClaimsUncheckedUpdateInput>
  }

  /**
   * AspNetUserClaims delete
   */
  export type AspNetUserClaimsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserClaims to delete.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims deleteMany
   */
  export type AspNetUserClaimsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserClaims to delete
     */
    where?: AspNetUserClaimsWhereInput
  }

  /**
   * AspNetUserClaims without action
   */
  export type AspNetUserClaimsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserLogins
   */

  export type AggregateAspNetUserLogins = {
    _count: AspNetUserLoginsCountAggregateOutputType | null
    _avg: AspNetUserLoginsAvgAggregateOutputType | null
    _sum: AspNetUserLoginsSumAggregateOutputType | null
    _min: AspNetUserLoginsMinAggregateOutputType | null
    _max: AspNetUserLoginsMaxAggregateOutputType | null
  }

  export type AspNetUserLoginsAvgAggregateOutputType = {
    UserId: number | null
  }

  export type AspNetUserLoginsSumAggregateOutputType = {
    UserId: number | null
  }

  export type AspNetUserLoginsMinAggregateOutputType = {
    LoginProvider: string | null
    ProviderKey: string | null
    ProviderDisplayName: string | null
    UserId: number | null
  }

  export type AspNetUserLoginsMaxAggregateOutputType = {
    LoginProvider: string | null
    ProviderKey: string | null
    ProviderDisplayName: string | null
    UserId: number | null
  }

  export type AspNetUserLoginsCountAggregateOutputType = {
    LoginProvider: number
    ProviderKey: number
    ProviderDisplayName: number
    UserId: number
    _all: number
  }


  export type AspNetUserLoginsAvgAggregateInputType = {
    UserId?: true
  }

  export type AspNetUserLoginsSumAggregateInputType = {
    UserId?: true
  }

  export type AspNetUserLoginsMinAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
  }

  export type AspNetUserLoginsMaxAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
  }

  export type AspNetUserLoginsCountAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
    _all?: true
  }

  export type AspNetUserLoginsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserLogins to aggregate.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserLogins
    **/
    _count?: true | AspNetUserLoginsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetUserLoginsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetUserLoginsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserLoginsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserLoginsMaxAggregateInputType
  }

  export type GetAspNetUserLoginsAggregateType<T extends AspNetUserLoginsAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserLogins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserLogins[P]>
      : GetScalarType<T[P], AggregateAspNetUserLogins[P]>
  }




  export type AspNetUserLoginsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserLoginsWhereInput
    orderBy?: AspNetUserLoginsOrderByWithAggregationInput | AspNetUserLoginsOrderByWithAggregationInput[]
    by: AspNetUserLoginsScalarFieldEnum[] | AspNetUserLoginsScalarFieldEnum
    having?: AspNetUserLoginsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserLoginsCountAggregateInputType | true
    _avg?: AspNetUserLoginsAvgAggregateInputType
    _sum?: AspNetUserLoginsSumAggregateInputType
    _min?: AspNetUserLoginsMinAggregateInputType
    _max?: AspNetUserLoginsMaxAggregateInputType
  }

  export type AspNetUserLoginsGroupByOutputType = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName: string | null
    UserId: number
    _count: AspNetUserLoginsCountAggregateOutputType | null
    _avg: AspNetUserLoginsAvgAggregateOutputType | null
    _sum: AspNetUserLoginsSumAggregateOutputType | null
    _min: AspNetUserLoginsMinAggregateOutputType | null
    _max: AspNetUserLoginsMaxAggregateOutputType | null
  }

  type GetAspNetUserLoginsGroupByPayload<T extends AspNetUserLoginsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserLoginsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserLoginsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserLoginsGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserLoginsGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserLoginsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LoginProvider?: boolean
    ProviderKey?: boolean
    ProviderDisplayName?: boolean
    UserId?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserLogins"]>

  export type AspNetUserLoginsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LoginProvider?: boolean
    ProviderKey?: boolean
    ProviderDisplayName?: boolean
    UserId?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserLogins"]>

  export type AspNetUserLoginsSelectScalar = {
    LoginProvider?: boolean
    ProviderKey?: boolean
    ProviderDisplayName?: boolean
    UserId?: boolean
  }

  export type AspNetUserLoginsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }
  export type AspNetUserLoginsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserLoginsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserLogins"
    objects: {
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      LoginProvider: string
      ProviderKey: string
      ProviderDisplayName: string | null
      UserId: number
    }, ExtArgs["result"]["aspNetUserLogins"]>
    composites: {}
  }

  type AspNetUserLoginsGetPayload<S extends boolean | null | undefined | AspNetUserLoginsDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserLoginsPayload, S>

  type AspNetUserLoginsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AspNetUserLoginsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AspNetUserLoginsCountAggregateInputType | true
    }

  export interface AspNetUserLoginsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserLogins'], meta: { name: 'AspNetUserLogins' } }
    /**
     * Find zero or one AspNetUserLogins that matches the filter.
     * @param {AspNetUserLoginsFindUniqueArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserLoginsFindUniqueArgs>(args: SelectSubset<T, AspNetUserLoginsFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AspNetUserLogins that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AspNetUserLoginsFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserLoginsFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserLoginsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AspNetUserLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsFindFirstArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserLoginsFindFirstArgs>(args?: SelectSubset<T, AspNetUserLoginsFindFirstArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AspNetUserLogins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsFindFirstOrThrowArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserLoginsFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserLoginsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AspNetUserLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findMany()
     * 
     * // Get first 10 AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findMany({ take: 10 })
     * 
     * // Only select the `LoginProvider`
     * const aspNetUserLoginsWithLoginProviderOnly = await prisma.aspNetUserLogins.findMany({ select: { LoginProvider: true } })
     * 
     */
    findMany<T extends AspNetUserLoginsFindManyArgs>(args?: SelectSubset<T, AspNetUserLoginsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AspNetUserLogins.
     * @param {AspNetUserLoginsCreateArgs} args - Arguments to create a AspNetUserLogins.
     * @example
     * // Create one AspNetUserLogins
     * const AspNetUserLogins = await prisma.aspNetUserLogins.create({
     *   data: {
     *     // ... data to create a AspNetUserLogins
     *   }
     * })
     * 
     */
    create<T extends AspNetUserLoginsCreateArgs>(args: SelectSubset<T, AspNetUserLoginsCreateArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AspNetUserLogins.
     * @param {AspNetUserLoginsCreateManyArgs} args - Arguments to create many AspNetUserLogins.
     * @example
     * // Create many AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserLoginsCreateManyArgs>(args?: SelectSubset<T, AspNetUserLoginsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspNetUserLogins and returns the data saved in the database.
     * @param {AspNetUserLoginsCreateManyAndReturnArgs} args - Arguments to create many AspNetUserLogins.
     * @example
     * // Create many AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspNetUserLogins and only return the `LoginProvider`
     * const aspNetUserLoginsWithLoginProviderOnly = await prisma.aspNetUserLogins.createManyAndReturn({ 
     *   select: { LoginProvider: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspNetUserLoginsCreateManyAndReturnArgs>(args?: SelectSubset<T, AspNetUserLoginsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AspNetUserLogins.
     * @param {AspNetUserLoginsDeleteArgs} args - Arguments to delete one AspNetUserLogins.
     * @example
     * // Delete one AspNetUserLogins
     * const AspNetUserLogins = await prisma.aspNetUserLogins.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserLogins
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserLoginsDeleteArgs>(args: SelectSubset<T, AspNetUserLoginsDeleteArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AspNetUserLogins.
     * @param {AspNetUserLoginsUpdateArgs} args - Arguments to update one AspNetUserLogins.
     * @example
     * // Update one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserLoginsUpdateArgs>(args: SelectSubset<T, AspNetUserLoginsUpdateArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AspNetUserLogins.
     * @param {AspNetUserLoginsDeleteManyArgs} args - Arguments to filter AspNetUserLogins to delete.
     * @example
     * // Delete a few AspNetUserLogins
     * const { count } = await prisma.aspNetUserLogins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserLoginsDeleteManyArgs>(args?: SelectSubset<T, AspNetUserLoginsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserLoginsUpdateManyArgs>(args: SelectSubset<T, AspNetUserLoginsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserLogins.
     * @param {AspNetUserLoginsUpsertArgs} args - Arguments to update or create a AspNetUserLogins.
     * @example
     * // Update or create a AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.upsert({
     *   create: {
     *     // ... data to create a AspNetUserLogins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserLogins we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserLoginsUpsertArgs>(args: SelectSubset<T, AspNetUserLoginsUpsertArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsCountArgs} args - Arguments to filter AspNetUserLogins to count.
     * @example
     * // Count the number of AspNetUserLogins
     * const count = await prisma.aspNetUserLogins.count({
     *   where: {
     *     // ... the filter for the AspNetUserLogins we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserLoginsCountArgs>(
      args?: Subset<T, AspNetUserLoginsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserLoginsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserLoginsAggregateArgs>(args: Subset<T, AspNetUserLoginsAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserLoginsAggregateType<T>>

    /**
     * Group by AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserLoginsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserLoginsGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserLoginsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserLoginsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserLoginsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserLogins model
   */
  readonly fields: AspNetUserLoginsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserLogins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserLoginsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserLogins model
   */ 
  interface AspNetUserLoginsFieldRefs {
    readonly LoginProvider: FieldRef<"AspNetUserLogins", 'String'>
    readonly ProviderKey: FieldRef<"AspNetUserLogins", 'String'>
    readonly ProviderDisplayName: FieldRef<"AspNetUserLogins", 'String'>
    readonly UserId: FieldRef<"AspNetUserLogins", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserLogins findUnique
   */
  export type AspNetUserLoginsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins findUniqueOrThrow
   */
  export type AspNetUserLoginsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins findFirst
   */
  export type AspNetUserLoginsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserLogins.
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserLogins.
     */
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUserLogins findFirstOrThrow
   */
  export type AspNetUserLoginsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserLogins.
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserLogins.
     */
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUserLogins findMany
   */
  export type AspNetUserLoginsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserLogins.
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUserLogins create
   */
  export type AspNetUserLoginsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserLogins.
     */
    data: XOR<AspNetUserLoginsCreateInput, AspNetUserLoginsUncheckedCreateInput>
  }

  /**
   * AspNetUserLogins createMany
   */
  export type AspNetUserLoginsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserLogins.
     */
    data: AspNetUserLoginsCreateManyInput | AspNetUserLoginsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetUserLogins createManyAndReturn
   */
  export type AspNetUserLoginsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AspNetUserLogins.
     */
    data: AspNetUserLoginsCreateManyInput | AspNetUserLoginsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AspNetUserLogins update
   */
  export type AspNetUserLoginsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserLogins.
     */
    data: XOR<AspNetUserLoginsUpdateInput, AspNetUserLoginsUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserLogins to update.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins updateMany
   */
  export type AspNetUserLoginsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserLogins.
     */
    data: XOR<AspNetUserLoginsUpdateManyMutationInput, AspNetUserLoginsUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserLogins to update
     */
    where?: AspNetUserLoginsWhereInput
  }

  /**
   * AspNetUserLogins upsert
   */
  export type AspNetUserLoginsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserLogins to update in case it exists.
     */
    where: AspNetUserLoginsWhereUniqueInput
    /**
     * In case the AspNetUserLogins found by the `where` argument doesn't exist, create a new AspNetUserLogins with this data.
     */
    create: XOR<AspNetUserLoginsCreateInput, AspNetUserLoginsUncheckedCreateInput>
    /**
     * In case the AspNetUserLogins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserLoginsUpdateInput, AspNetUserLoginsUncheckedUpdateInput>
  }

  /**
   * AspNetUserLogins delete
   */
  export type AspNetUserLoginsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserLogins to delete.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins deleteMany
   */
  export type AspNetUserLoginsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserLogins to delete
     */
    where?: AspNetUserLoginsWhereInput
  }

  /**
   * AspNetUserLogins without action
   */
  export type AspNetUserLoginsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserRoles
   */

  export type AggregateAspNetUserRoles = {
    _count: AspNetUserRolesCountAggregateOutputType | null
    _avg: AspNetUserRolesAvgAggregateOutputType | null
    _sum: AspNetUserRolesSumAggregateOutputType | null
    _min: AspNetUserRolesMinAggregateOutputType | null
    _max: AspNetUserRolesMaxAggregateOutputType | null
  }

  export type AspNetUserRolesAvgAggregateOutputType = {
    UserId: number | null
    RoleId: number | null
  }

  export type AspNetUserRolesSumAggregateOutputType = {
    UserId: number | null
    RoleId: number | null
  }

  export type AspNetUserRolesMinAggregateOutputType = {
    UserId: number | null
    RoleId: number | null
  }

  export type AspNetUserRolesMaxAggregateOutputType = {
    UserId: number | null
    RoleId: number | null
  }

  export type AspNetUserRolesCountAggregateOutputType = {
    UserId: number
    RoleId: number
    _all: number
  }


  export type AspNetUserRolesAvgAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type AspNetUserRolesSumAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type AspNetUserRolesMinAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type AspNetUserRolesMaxAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type AspNetUserRolesCountAggregateInputType = {
    UserId?: true
    RoleId?: true
    _all?: true
  }

  export type AspNetUserRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserRoles to aggregate.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserRoles
    **/
    _count?: true | AspNetUserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetUserRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetUserRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserRolesMaxAggregateInputType
  }

  export type GetAspNetUserRolesAggregateType<T extends AspNetUserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserRoles[P]>
      : GetScalarType<T[P], AggregateAspNetUserRoles[P]>
  }




  export type AspNetUserRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserRolesWhereInput
    orderBy?: AspNetUserRolesOrderByWithAggregationInput | AspNetUserRolesOrderByWithAggregationInput[]
    by: AspNetUserRolesScalarFieldEnum[] | AspNetUserRolesScalarFieldEnum
    having?: AspNetUserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserRolesCountAggregateInputType | true
    _avg?: AspNetUserRolesAvgAggregateInputType
    _sum?: AspNetUserRolesSumAggregateInputType
    _min?: AspNetUserRolesMinAggregateInputType
    _max?: AspNetUserRolesMaxAggregateInputType
  }

  export type AspNetUserRolesGroupByOutputType = {
    UserId: number
    RoleId: number
    _count: AspNetUserRolesCountAggregateOutputType | null
    _avg: AspNetUserRolesAvgAggregateOutputType | null
    _sum: AspNetUserRolesSumAggregateOutputType | null
    _min: AspNetUserRolesMinAggregateOutputType | null
    _max: AspNetUserRolesMaxAggregateOutputType | null
  }

  type GetAspNetUserRolesGroupByPayload<T extends AspNetUserRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserRolesGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    RoleId?: boolean
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserRoles"]>

  export type AspNetUserRolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    RoleId?: boolean
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserRoles"]>

  export type AspNetUserRolesSelectScalar = {
    UserId?: boolean
    RoleId?: boolean
  }

  export type AspNetUserRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }
  export type AspNetUserRolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserRoles"
    objects: {
      AspNetRoles: Prisma.$AspNetRolesPayload<ExtArgs>
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      UserId: number
      RoleId: number
    }, ExtArgs["result"]["aspNetUserRoles"]>
    composites: {}
  }

  type AspNetUserRolesGetPayload<S extends boolean | null | undefined | AspNetUserRolesDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserRolesPayload, S>

  type AspNetUserRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AspNetUserRolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AspNetUserRolesCountAggregateInputType | true
    }

  export interface AspNetUserRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserRoles'], meta: { name: 'AspNetUserRoles' } }
    /**
     * Find zero or one AspNetUserRoles that matches the filter.
     * @param {AspNetUserRolesFindUniqueArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserRolesFindUniqueArgs>(args: SelectSubset<T, AspNetUserRolesFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AspNetUserRoles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AspNetUserRolesFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AspNetUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesFindFirstArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserRolesFindFirstArgs>(args?: SelectSubset<T, AspNetUserRolesFindFirstArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AspNetUserRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesFindFirstOrThrowArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AspNetUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findMany()
     * 
     * // Get first 10 AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const aspNetUserRolesWithUserIdOnly = await prisma.aspNetUserRoles.findMany({ select: { UserId: true } })
     * 
     */
    findMany<T extends AspNetUserRolesFindManyArgs>(args?: SelectSubset<T, AspNetUserRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AspNetUserRoles.
     * @param {AspNetUserRolesCreateArgs} args - Arguments to create a AspNetUserRoles.
     * @example
     * // Create one AspNetUserRoles
     * const AspNetUserRoles = await prisma.aspNetUserRoles.create({
     *   data: {
     *     // ... data to create a AspNetUserRoles
     *   }
     * })
     * 
     */
    create<T extends AspNetUserRolesCreateArgs>(args: SelectSubset<T, AspNetUserRolesCreateArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AspNetUserRoles.
     * @param {AspNetUserRolesCreateManyArgs} args - Arguments to create many AspNetUserRoles.
     * @example
     * // Create many AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserRolesCreateManyArgs>(args?: SelectSubset<T, AspNetUserRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspNetUserRoles and returns the data saved in the database.
     * @param {AspNetUserRolesCreateManyAndReturnArgs} args - Arguments to create many AspNetUserRoles.
     * @example
     * // Create many AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspNetUserRoles and only return the `UserId`
     * const aspNetUserRolesWithUserIdOnly = await prisma.aspNetUserRoles.createManyAndReturn({ 
     *   select: { UserId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspNetUserRolesCreateManyAndReturnArgs>(args?: SelectSubset<T, AspNetUserRolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AspNetUserRoles.
     * @param {AspNetUserRolesDeleteArgs} args - Arguments to delete one AspNetUserRoles.
     * @example
     * // Delete one AspNetUserRoles
     * const AspNetUserRoles = await prisma.aspNetUserRoles.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserRoles
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserRolesDeleteArgs>(args: SelectSubset<T, AspNetUserRolesDeleteArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AspNetUserRoles.
     * @param {AspNetUserRolesUpdateArgs} args - Arguments to update one AspNetUserRoles.
     * @example
     * // Update one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserRolesUpdateArgs>(args: SelectSubset<T, AspNetUserRolesUpdateArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AspNetUserRoles.
     * @param {AspNetUserRolesDeleteManyArgs} args - Arguments to filter AspNetUserRoles to delete.
     * @example
     * // Delete a few AspNetUserRoles
     * const { count } = await prisma.aspNetUserRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserRolesDeleteManyArgs>(args?: SelectSubset<T, AspNetUserRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserRolesUpdateManyArgs>(args: SelectSubset<T, AspNetUserRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserRoles.
     * @param {AspNetUserRolesUpsertArgs} args - Arguments to update or create a AspNetUserRoles.
     * @example
     * // Update or create a AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.upsert({
     *   create: {
     *     // ... data to create a AspNetUserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserRoles we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserRolesUpsertArgs>(args: SelectSubset<T, AspNetUserRolesUpsertArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesCountArgs} args - Arguments to filter AspNetUserRoles to count.
     * @example
     * // Count the number of AspNetUserRoles
     * const count = await prisma.aspNetUserRoles.count({
     *   where: {
     *     // ... the filter for the AspNetUserRoles we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserRolesCountArgs>(
      args?: Subset<T, AspNetUserRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserRolesAggregateArgs>(args: Subset<T, AspNetUserRolesAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserRolesAggregateType<T>>

    /**
     * Group by AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserRolesGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserRoles model
   */
  readonly fields: AspNetUserRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetRoles<T extends AspNetRolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRolesDefaultArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserRoles model
   */ 
  interface AspNetUserRolesFieldRefs {
    readonly UserId: FieldRef<"AspNetUserRoles", 'Int'>
    readonly RoleId: FieldRef<"AspNetUserRoles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserRoles findUnique
   */
  export type AspNetUserRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles findUniqueOrThrow
   */
  export type AspNetUserRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles findFirst
   */
  export type AspNetUserRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserRoles.
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserRoles.
     */
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUserRoles findFirstOrThrow
   */
  export type AspNetUserRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserRoles.
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserRoles.
     */
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUserRoles findMany
   */
  export type AspNetUserRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserRoles.
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUserRoles create
   */
  export type AspNetUserRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserRoles.
     */
    data: XOR<AspNetUserRolesCreateInput, AspNetUserRolesUncheckedCreateInput>
  }

  /**
   * AspNetUserRoles createMany
   */
  export type AspNetUserRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserRoles.
     */
    data: AspNetUserRolesCreateManyInput | AspNetUserRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetUserRoles createManyAndReturn
   */
  export type AspNetUserRolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AspNetUserRoles.
     */
    data: AspNetUserRolesCreateManyInput | AspNetUserRolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AspNetUserRoles update
   */
  export type AspNetUserRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserRoles.
     */
    data: XOR<AspNetUserRolesUpdateInput, AspNetUserRolesUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserRoles to update.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles updateMany
   */
  export type AspNetUserRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserRoles.
     */
    data: XOR<AspNetUserRolesUpdateManyMutationInput, AspNetUserRolesUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserRoles to update
     */
    where?: AspNetUserRolesWhereInput
  }

  /**
   * AspNetUserRoles upsert
   */
  export type AspNetUserRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserRoles to update in case it exists.
     */
    where: AspNetUserRolesWhereUniqueInput
    /**
     * In case the AspNetUserRoles found by the `where` argument doesn't exist, create a new AspNetUserRoles with this data.
     */
    create: XOR<AspNetUserRolesCreateInput, AspNetUserRolesUncheckedCreateInput>
    /**
     * In case the AspNetUserRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserRolesUpdateInput, AspNetUserRolesUncheckedUpdateInput>
  }

  /**
   * AspNetUserRoles delete
   */
  export type AspNetUserRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserRoles to delete.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles deleteMany
   */
  export type AspNetUserRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserRoles to delete
     */
    where?: AspNetUserRolesWhereInput
  }

  /**
   * AspNetUserRoles without action
   */
  export type AspNetUserRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserTokens
   */

  export type AggregateAspNetUserTokens = {
    _count: AspNetUserTokensCountAggregateOutputType | null
    _avg: AspNetUserTokensAvgAggregateOutputType | null
    _sum: AspNetUserTokensSumAggregateOutputType | null
    _min: AspNetUserTokensMinAggregateOutputType | null
    _max: AspNetUserTokensMaxAggregateOutputType | null
  }

  export type AspNetUserTokensAvgAggregateOutputType = {
    UserId: number | null
  }

  export type AspNetUserTokensSumAggregateOutputType = {
    UserId: number | null
  }

  export type AspNetUserTokensMinAggregateOutputType = {
    UserId: number | null
    LoginProvider: string | null
    Name: string | null
    Value: string | null
  }

  export type AspNetUserTokensMaxAggregateOutputType = {
    UserId: number | null
    LoginProvider: string | null
    Name: string | null
    Value: string | null
  }

  export type AspNetUserTokensCountAggregateOutputType = {
    UserId: number
    LoginProvider: number
    Name: number
    Value: number
    _all: number
  }


  export type AspNetUserTokensAvgAggregateInputType = {
    UserId?: true
  }

  export type AspNetUserTokensSumAggregateInputType = {
    UserId?: true
  }

  export type AspNetUserTokensMinAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
  }

  export type AspNetUserTokensMaxAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
  }

  export type AspNetUserTokensCountAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
    _all?: true
  }

  export type AspNetUserTokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserTokens to aggregate.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserTokens
    **/
    _count?: true | AspNetUserTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetUserTokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetUserTokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserTokensMaxAggregateInputType
  }

  export type GetAspNetUserTokensAggregateType<T extends AspNetUserTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserTokens[P]>
      : GetScalarType<T[P], AggregateAspNetUserTokens[P]>
  }




  export type AspNetUserTokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserTokensWhereInput
    orderBy?: AspNetUserTokensOrderByWithAggregationInput | AspNetUserTokensOrderByWithAggregationInput[]
    by: AspNetUserTokensScalarFieldEnum[] | AspNetUserTokensScalarFieldEnum
    having?: AspNetUserTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserTokensCountAggregateInputType | true
    _avg?: AspNetUserTokensAvgAggregateInputType
    _sum?: AspNetUserTokensSumAggregateInputType
    _min?: AspNetUserTokensMinAggregateInputType
    _max?: AspNetUserTokensMaxAggregateInputType
  }

  export type AspNetUserTokensGroupByOutputType = {
    UserId: number
    LoginProvider: string
    Name: string
    Value: string | null
    _count: AspNetUserTokensCountAggregateOutputType | null
    _avg: AspNetUserTokensAvgAggregateOutputType | null
    _sum: AspNetUserTokensSumAggregateOutputType | null
    _min: AspNetUserTokensMinAggregateOutputType | null
    _max: AspNetUserTokensMaxAggregateOutputType | null
  }

  type GetAspNetUserTokensGroupByPayload<T extends AspNetUserTokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserTokensGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserTokensGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserTokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    LoginProvider?: boolean
    Name?: boolean
    Value?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserTokens"]>

  export type AspNetUserTokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    LoginProvider?: boolean
    Name?: boolean
    Value?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserTokens"]>

  export type AspNetUserTokensSelectScalar = {
    UserId?: boolean
    LoginProvider?: boolean
    Name?: boolean
    Value?: boolean
  }

  export type AspNetUserTokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }
  export type AspNetUserTokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserTokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserTokens"
    objects: {
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      UserId: number
      LoginProvider: string
      Name: string
      Value: string | null
    }, ExtArgs["result"]["aspNetUserTokens"]>
    composites: {}
  }

  type AspNetUserTokensGetPayload<S extends boolean | null | undefined | AspNetUserTokensDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserTokensPayload, S>

  type AspNetUserTokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AspNetUserTokensFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AspNetUserTokensCountAggregateInputType | true
    }

  export interface AspNetUserTokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserTokens'], meta: { name: 'AspNetUserTokens' } }
    /**
     * Find zero or one AspNetUserTokens that matches the filter.
     * @param {AspNetUserTokensFindUniqueArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserTokensFindUniqueArgs>(args: SelectSubset<T, AspNetUserTokensFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AspNetUserTokens that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AspNetUserTokensFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserTokensFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserTokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AspNetUserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensFindFirstArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserTokensFindFirstArgs>(args?: SelectSubset<T, AspNetUserTokensFindFirstArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AspNetUserTokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensFindFirstOrThrowArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserTokensFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserTokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AspNetUserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findMany()
     * 
     * // Get first 10 AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const aspNetUserTokensWithUserIdOnly = await prisma.aspNetUserTokens.findMany({ select: { UserId: true } })
     * 
     */
    findMany<T extends AspNetUserTokensFindManyArgs>(args?: SelectSubset<T, AspNetUserTokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AspNetUserTokens.
     * @param {AspNetUserTokensCreateArgs} args - Arguments to create a AspNetUserTokens.
     * @example
     * // Create one AspNetUserTokens
     * const AspNetUserTokens = await prisma.aspNetUserTokens.create({
     *   data: {
     *     // ... data to create a AspNetUserTokens
     *   }
     * })
     * 
     */
    create<T extends AspNetUserTokensCreateArgs>(args: SelectSubset<T, AspNetUserTokensCreateArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AspNetUserTokens.
     * @param {AspNetUserTokensCreateManyArgs} args - Arguments to create many AspNetUserTokens.
     * @example
     * // Create many AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserTokensCreateManyArgs>(args?: SelectSubset<T, AspNetUserTokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspNetUserTokens and returns the data saved in the database.
     * @param {AspNetUserTokensCreateManyAndReturnArgs} args - Arguments to create many AspNetUserTokens.
     * @example
     * // Create many AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspNetUserTokens and only return the `UserId`
     * const aspNetUserTokensWithUserIdOnly = await prisma.aspNetUserTokens.createManyAndReturn({ 
     *   select: { UserId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspNetUserTokensCreateManyAndReturnArgs>(args?: SelectSubset<T, AspNetUserTokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AspNetUserTokens.
     * @param {AspNetUserTokensDeleteArgs} args - Arguments to delete one AspNetUserTokens.
     * @example
     * // Delete one AspNetUserTokens
     * const AspNetUserTokens = await prisma.aspNetUserTokens.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserTokens
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserTokensDeleteArgs>(args: SelectSubset<T, AspNetUserTokensDeleteArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AspNetUserTokens.
     * @param {AspNetUserTokensUpdateArgs} args - Arguments to update one AspNetUserTokens.
     * @example
     * // Update one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserTokensUpdateArgs>(args: SelectSubset<T, AspNetUserTokensUpdateArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AspNetUserTokens.
     * @param {AspNetUserTokensDeleteManyArgs} args - Arguments to filter AspNetUserTokens to delete.
     * @example
     * // Delete a few AspNetUserTokens
     * const { count } = await prisma.aspNetUserTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserTokensDeleteManyArgs>(args?: SelectSubset<T, AspNetUserTokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserTokensUpdateManyArgs>(args: SelectSubset<T, AspNetUserTokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserTokens.
     * @param {AspNetUserTokensUpsertArgs} args - Arguments to update or create a AspNetUserTokens.
     * @example
     * // Update or create a AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.upsert({
     *   create: {
     *     // ... data to create a AspNetUserTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserTokens we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserTokensUpsertArgs>(args: SelectSubset<T, AspNetUserTokensUpsertArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensCountArgs} args - Arguments to filter AspNetUserTokens to count.
     * @example
     * // Count the number of AspNetUserTokens
     * const count = await prisma.aspNetUserTokens.count({
     *   where: {
     *     // ... the filter for the AspNetUserTokens we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserTokensCountArgs>(
      args?: Subset<T, AspNetUserTokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserTokensAggregateArgs>(args: Subset<T, AspNetUserTokensAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserTokensAggregateType<T>>

    /**
     * Group by AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserTokensGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserTokens model
   */
  readonly fields: AspNetUserTokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserTokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserTokens model
   */ 
  interface AspNetUserTokensFieldRefs {
    readonly UserId: FieldRef<"AspNetUserTokens", 'Int'>
    readonly LoginProvider: FieldRef<"AspNetUserTokens", 'String'>
    readonly Name: FieldRef<"AspNetUserTokens", 'String'>
    readonly Value: FieldRef<"AspNetUserTokens", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserTokens findUnique
   */
  export type AspNetUserTokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens findUniqueOrThrow
   */
  export type AspNetUserTokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens findFirst
   */
  export type AspNetUserTokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserTokens.
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserTokens.
     */
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUserTokens findFirstOrThrow
   */
  export type AspNetUserTokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserTokens.
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserTokens.
     */
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUserTokens findMany
   */
  export type AspNetUserTokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserTokens.
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUserTokens create
   */
  export type AspNetUserTokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserTokens.
     */
    data: XOR<AspNetUserTokensCreateInput, AspNetUserTokensUncheckedCreateInput>
  }

  /**
   * AspNetUserTokens createMany
   */
  export type AspNetUserTokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserTokens.
     */
    data: AspNetUserTokensCreateManyInput | AspNetUserTokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetUserTokens createManyAndReturn
   */
  export type AspNetUserTokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AspNetUserTokens.
     */
    data: AspNetUserTokensCreateManyInput | AspNetUserTokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AspNetUserTokens update
   */
  export type AspNetUserTokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserTokens.
     */
    data: XOR<AspNetUserTokensUpdateInput, AspNetUserTokensUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserTokens to update.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens updateMany
   */
  export type AspNetUserTokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserTokens.
     */
    data: XOR<AspNetUserTokensUpdateManyMutationInput, AspNetUserTokensUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserTokens to update
     */
    where?: AspNetUserTokensWhereInput
  }

  /**
   * AspNetUserTokens upsert
   */
  export type AspNetUserTokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserTokens to update in case it exists.
     */
    where: AspNetUserTokensWhereUniqueInput
    /**
     * In case the AspNetUserTokens found by the `where` argument doesn't exist, create a new AspNetUserTokens with this data.
     */
    create: XOR<AspNetUserTokensCreateInput, AspNetUserTokensUncheckedCreateInput>
    /**
     * In case the AspNetUserTokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserTokensUpdateInput, AspNetUserTokensUncheckedUpdateInput>
  }

  /**
   * AspNetUserTokens delete
   */
  export type AspNetUserTokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserTokens to delete.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens deleteMany
   */
  export type AspNetUserTokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserTokens to delete
     */
    where?: AspNetUserTokensWhereInput
  }

  /**
   * AspNetUserTokens without action
   */
  export type AspNetUserTokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUsers
   */

  export type AggregateAspNetUsers = {
    _count: AspNetUsersCountAggregateOutputType | null
    _avg: AspNetUsersAvgAggregateOutputType | null
    _sum: AspNetUsersSumAggregateOutputType | null
    _min: AspNetUsersMinAggregateOutputType | null
    _max: AspNetUsersMaxAggregateOutputType | null
  }

  export type AspNetUsersAvgAggregateOutputType = {
    Id: number | null
    AccessFailedCount: number | null
  }

  export type AspNetUsersSumAggregateOutputType = {
    Id: number | null
    AccessFailedCount: number | null
  }

  export type AspNetUsersMinAggregateOutputType = {
    Id: number | null
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean | null
    PasswordHash: string | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean | null
    TwoFactorEnabled: boolean | null
    LockoutEnd: Date | null
    LockoutEnabled: boolean | null
    AccessFailedCount: number | null
    Name: string | null
    Nickname: string | null
    CreatedAt: Date | null
  }

  export type AspNetUsersMaxAggregateOutputType = {
    Id: number | null
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean | null
    PasswordHash: string | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean | null
    TwoFactorEnabled: boolean | null
    LockoutEnd: Date | null
    LockoutEnabled: boolean | null
    AccessFailedCount: number | null
    Name: string | null
    Nickname: string | null
    CreatedAt: Date | null
  }

  export type AspNetUsersCountAggregateOutputType = {
    Id: number
    UserName: number
    NormalizedUserName: number
    Email: number
    NormalizedEmail: number
    EmailConfirmed: number
    PasswordHash: number
    SecurityStamp: number
    ConcurrencyStamp: number
    PhoneNumber: number
    PhoneNumberConfirmed: number
    TwoFactorEnabled: number
    LockoutEnd: number
    LockoutEnabled: number
    AccessFailedCount: number
    Name: number
    Nickname: number
    CreatedAt: number
    _all: number
  }


  export type AspNetUsersAvgAggregateInputType = {
    Id?: true
    AccessFailedCount?: true
  }

  export type AspNetUsersSumAggregateInputType = {
    Id?: true
    AccessFailedCount?: true
  }

  export type AspNetUsersMinAggregateInputType = {
    Id?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    PasswordHash?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
    Name?: true
    Nickname?: true
    CreatedAt?: true
  }

  export type AspNetUsersMaxAggregateInputType = {
    Id?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    PasswordHash?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
    Name?: true
    Nickname?: true
    CreatedAt?: true
  }

  export type AspNetUsersCountAggregateInputType = {
    Id?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    PasswordHash?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
    Name?: true
    Nickname?: true
    CreatedAt?: true
    _all?: true
  }

  export type AspNetUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUsers to aggregate.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUsers
    **/
    _count?: true | AspNetUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUsersMaxAggregateInputType
  }

  export type GetAspNetUsersAggregateType<T extends AspNetUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUsers[P]>
      : GetScalarType<T[P], AggregateAspNetUsers[P]>
  }




  export type AspNetUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUsersWhereInput
    orderBy?: AspNetUsersOrderByWithAggregationInput | AspNetUsersOrderByWithAggregationInput[]
    by: AspNetUsersScalarFieldEnum[] | AspNetUsersScalarFieldEnum
    having?: AspNetUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUsersCountAggregateInputType | true
    _avg?: AspNetUsersAvgAggregateInputType
    _sum?: AspNetUsersSumAggregateInputType
    _min?: AspNetUsersMinAggregateInputType
    _max?: AspNetUsersMaxAggregateInputType
  }

  export type AspNetUsersGroupByOutputType = {
    Id: number
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean
    PasswordHash: string | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd: Date | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name: string
    Nickname: string
    CreatedAt: Date
    _count: AspNetUsersCountAggregateOutputType | null
    _avg: AspNetUsersAvgAggregateOutputType | null
    _sum: AspNetUsersSumAggregateOutputType | null
    _min: AspNetUsersMinAggregateOutputType | null
    _max: AspNetUsersMaxAggregateOutputType | null
  }

  type GetAspNetUsersGroupByPayload<T extends AspNetUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUsersGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUsersGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserName?: boolean
    NormalizedUserName?: boolean
    Email?: boolean
    NormalizedEmail?: boolean
    EmailConfirmed?: boolean
    PasswordHash?: boolean
    SecurityStamp?: boolean
    ConcurrencyStamp?: boolean
    PhoneNumber?: boolean
    PhoneNumberConfirmed?: boolean
    TwoFactorEnabled?: boolean
    LockoutEnd?: boolean
    LockoutEnabled?: boolean
    AccessFailedCount?: boolean
    Name?: boolean
    Nickname?: boolean
    CreatedAt?: boolean
    AspNetUserClaims?: boolean | AspNetUsers$AspNetUserClaimsArgs<ExtArgs>
    AspNetUserLogins?: boolean | AspNetUsers$AspNetUserLoginsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetUsers$AspNetUserRolesArgs<ExtArgs>
    AspNetUserTokens?: boolean | AspNetUsers$AspNetUserTokensArgs<ExtArgs>
    Posts?: boolean | AspNetUsers$PostsArgs<ExtArgs>
    _count?: boolean | AspNetUsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUsers"]>

  export type AspNetUsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserName?: boolean
    NormalizedUserName?: boolean
    Email?: boolean
    NormalizedEmail?: boolean
    EmailConfirmed?: boolean
    PasswordHash?: boolean
    SecurityStamp?: boolean
    ConcurrencyStamp?: boolean
    PhoneNumber?: boolean
    PhoneNumberConfirmed?: boolean
    TwoFactorEnabled?: boolean
    LockoutEnd?: boolean
    LockoutEnabled?: boolean
    AccessFailedCount?: boolean
    Name?: boolean
    Nickname?: boolean
    CreatedAt?: boolean
  }, ExtArgs["result"]["aspNetUsers"]>

  export type AspNetUsersSelectScalar = {
    Id?: boolean
    UserName?: boolean
    NormalizedUserName?: boolean
    Email?: boolean
    NormalizedEmail?: boolean
    EmailConfirmed?: boolean
    PasswordHash?: boolean
    SecurityStamp?: boolean
    ConcurrencyStamp?: boolean
    PhoneNumber?: boolean
    PhoneNumberConfirmed?: boolean
    TwoFactorEnabled?: boolean
    LockoutEnd?: boolean
    LockoutEnabled?: boolean
    AccessFailedCount?: boolean
    Name?: boolean
    Nickname?: boolean
    CreatedAt?: boolean
  }

  export type AspNetUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUserClaims?: boolean | AspNetUsers$AspNetUserClaimsArgs<ExtArgs>
    AspNetUserLogins?: boolean | AspNetUsers$AspNetUserLoginsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetUsers$AspNetUserRolesArgs<ExtArgs>
    AspNetUserTokens?: boolean | AspNetUsers$AspNetUserTokensArgs<ExtArgs>
    Posts?: boolean | AspNetUsers$PostsArgs<ExtArgs>
    _count?: boolean | AspNetUsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AspNetUsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AspNetUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUsers"
    objects: {
      AspNetUserClaims: Prisma.$AspNetUserClaimsPayload<ExtArgs>[]
      AspNetUserLogins: Prisma.$AspNetUserLoginsPayload<ExtArgs>[]
      AspNetUserRoles: Prisma.$AspNetUserRolesPayload<ExtArgs>[]
      AspNetUserTokens: Prisma.$AspNetUserTokensPayload<ExtArgs>[]
      Posts: Prisma.$PostsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UserName: string | null
      NormalizedUserName: string | null
      Email: string | null
      NormalizedEmail: string | null
      EmailConfirmed: boolean
      PasswordHash: string | null
      SecurityStamp: string | null
      ConcurrencyStamp: string | null
      PhoneNumber: string | null
      PhoneNumberConfirmed: boolean
      TwoFactorEnabled: boolean
      LockoutEnd: Date | null
      LockoutEnabled: boolean
      AccessFailedCount: number
      Name: string
      Nickname: string
      CreatedAt: Date
    }, ExtArgs["result"]["aspNetUsers"]>
    composites: {}
  }

  type AspNetUsersGetPayload<S extends boolean | null | undefined | AspNetUsersDefaultArgs> = $Result.GetResult<Prisma.$AspNetUsersPayload, S>

  type AspNetUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AspNetUsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AspNetUsersCountAggregateInputType | true
    }

  export interface AspNetUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUsers'], meta: { name: 'AspNetUsers' } }
    /**
     * Find zero or one AspNetUsers that matches the filter.
     * @param {AspNetUsersFindUniqueArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUsersFindUniqueArgs>(args: SelectSubset<T, AspNetUsersFindUniqueArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AspNetUsers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AspNetUsersFindUniqueOrThrowArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUsersFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AspNetUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersFindFirstArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUsersFindFirstArgs>(args?: SelectSubset<T, AspNetUsersFindFirstArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AspNetUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersFindFirstOrThrowArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUsersFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AspNetUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findMany()
     * 
     * // Get first 10 AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetUsersWithIdOnly = await prisma.aspNetUsers.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetUsersFindManyArgs>(args?: SelectSubset<T, AspNetUsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AspNetUsers.
     * @param {AspNetUsersCreateArgs} args - Arguments to create a AspNetUsers.
     * @example
     * // Create one AspNetUsers
     * const AspNetUsers = await prisma.aspNetUsers.create({
     *   data: {
     *     // ... data to create a AspNetUsers
     *   }
     * })
     * 
     */
    create<T extends AspNetUsersCreateArgs>(args: SelectSubset<T, AspNetUsersCreateArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AspNetUsers.
     * @param {AspNetUsersCreateManyArgs} args - Arguments to create many AspNetUsers.
     * @example
     * // Create many AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUsersCreateManyArgs>(args?: SelectSubset<T, AspNetUsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspNetUsers and returns the data saved in the database.
     * @param {AspNetUsersCreateManyAndReturnArgs} args - Arguments to create many AspNetUsers.
     * @example
     * // Create many AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspNetUsers and only return the `Id`
     * const aspNetUsersWithIdOnly = await prisma.aspNetUsers.createManyAndReturn({ 
     *   select: { Id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspNetUsersCreateManyAndReturnArgs>(args?: SelectSubset<T, AspNetUsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AspNetUsers.
     * @param {AspNetUsersDeleteArgs} args - Arguments to delete one AspNetUsers.
     * @example
     * // Delete one AspNetUsers
     * const AspNetUsers = await prisma.aspNetUsers.delete({
     *   where: {
     *     // ... filter to delete one AspNetUsers
     *   }
     * })
     * 
     */
    delete<T extends AspNetUsersDeleteArgs>(args: SelectSubset<T, AspNetUsersDeleteArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AspNetUsers.
     * @param {AspNetUsersUpdateArgs} args - Arguments to update one AspNetUsers.
     * @example
     * // Update one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUsersUpdateArgs>(args: SelectSubset<T, AspNetUsersUpdateArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AspNetUsers.
     * @param {AspNetUsersDeleteManyArgs} args - Arguments to filter AspNetUsers to delete.
     * @example
     * // Delete a few AspNetUsers
     * const { count } = await prisma.aspNetUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUsersDeleteManyArgs>(args?: SelectSubset<T, AspNetUsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUsersUpdateManyArgs>(args: SelectSubset<T, AspNetUsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUsers.
     * @param {AspNetUsersUpsertArgs} args - Arguments to update or create a AspNetUsers.
     * @example
     * // Update or create a AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.upsert({
     *   create: {
     *     // ... data to create a AspNetUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUsers we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUsersUpsertArgs>(args: SelectSubset<T, AspNetUsersUpsertArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersCountArgs} args - Arguments to filter AspNetUsers to count.
     * @example
     * // Count the number of AspNetUsers
     * const count = await prisma.aspNetUsers.count({
     *   where: {
     *     // ... the filter for the AspNetUsers we want to count
     *   }
     * })
    **/
    count<T extends AspNetUsersCountArgs>(
      args?: Subset<T, AspNetUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUsersAggregateArgs>(args: Subset<T, AspNetUsersAggregateArgs>): Prisma.PrismaPromise<GetAspNetUsersAggregateType<T>>

    /**
     * Group by AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUsersGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUsers model
   */
  readonly fields: AspNetUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUserClaims<T extends AspNetUsers$AspNetUserClaimsArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findMany"> | Null>
    AspNetUserLogins<T extends AspNetUsers$AspNetUserLoginsArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserLoginsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findMany"> | Null>
    AspNetUserRoles<T extends AspNetUsers$AspNetUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findMany"> | Null>
    AspNetUserTokens<T extends AspNetUsers$AspNetUserTokensArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findMany"> | Null>
    Posts<T extends AspNetUsers$PostsArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$PostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUsers model
   */ 
  interface AspNetUsersFieldRefs {
    readonly Id: FieldRef<"AspNetUsers", 'Int'>
    readonly UserName: FieldRef<"AspNetUsers", 'String'>
    readonly NormalizedUserName: FieldRef<"AspNetUsers", 'String'>
    readonly Email: FieldRef<"AspNetUsers", 'String'>
    readonly NormalizedEmail: FieldRef<"AspNetUsers", 'String'>
    readonly EmailConfirmed: FieldRef<"AspNetUsers", 'Boolean'>
    readonly PasswordHash: FieldRef<"AspNetUsers", 'String'>
    readonly SecurityStamp: FieldRef<"AspNetUsers", 'String'>
    readonly ConcurrencyStamp: FieldRef<"AspNetUsers", 'String'>
    readonly PhoneNumber: FieldRef<"AspNetUsers", 'String'>
    readonly PhoneNumberConfirmed: FieldRef<"AspNetUsers", 'Boolean'>
    readonly TwoFactorEnabled: FieldRef<"AspNetUsers", 'Boolean'>
    readonly LockoutEnd: FieldRef<"AspNetUsers", 'DateTime'>
    readonly LockoutEnabled: FieldRef<"AspNetUsers", 'Boolean'>
    readonly AccessFailedCount: FieldRef<"AspNetUsers", 'Int'>
    readonly Name: FieldRef<"AspNetUsers", 'String'>
    readonly Nickname: FieldRef<"AspNetUsers", 'String'>
    readonly CreatedAt: FieldRef<"AspNetUsers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUsers findUnique
   */
  export type AspNetUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers findUniqueOrThrow
   */
  export type AspNetUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers findFirst
   */
  export type AspNetUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUsers.
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUsers.
     */
    distinct?: AspNetUsersScalarFieldEnum | AspNetUsersScalarFieldEnum[]
  }

  /**
   * AspNetUsers findFirstOrThrow
   */
  export type AspNetUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUsers.
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUsers.
     */
    distinct?: AspNetUsersScalarFieldEnum | AspNetUsersScalarFieldEnum[]
  }

  /**
   * AspNetUsers findMany
   */
  export type AspNetUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUsers.
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    distinct?: AspNetUsersScalarFieldEnum | AspNetUsersScalarFieldEnum[]
  }

  /**
   * AspNetUsers create
   */
  export type AspNetUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUsers.
     */
    data: XOR<AspNetUsersCreateInput, AspNetUsersUncheckedCreateInput>
  }

  /**
   * AspNetUsers createMany
   */
  export type AspNetUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUsers.
     */
    data: AspNetUsersCreateManyInput | AspNetUsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetUsers createManyAndReturn
   */
  export type AspNetUsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AspNetUsers.
     */
    data: AspNetUsersCreateManyInput | AspNetUsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspNetUsers update
   */
  export type AspNetUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUsers.
     */
    data: XOR<AspNetUsersUpdateInput, AspNetUsersUncheckedUpdateInput>
    /**
     * Choose, which AspNetUsers to update.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers updateMany
   */
  export type AspNetUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUsers.
     */
    data: XOR<AspNetUsersUpdateManyMutationInput, AspNetUsersUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUsers to update
     */
    where?: AspNetUsersWhereInput
  }

  /**
   * AspNetUsers upsert
   */
  export type AspNetUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUsers to update in case it exists.
     */
    where: AspNetUsersWhereUniqueInput
    /**
     * In case the AspNetUsers found by the `where` argument doesn't exist, create a new AspNetUsers with this data.
     */
    create: XOR<AspNetUsersCreateInput, AspNetUsersUncheckedCreateInput>
    /**
     * In case the AspNetUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUsersUpdateInput, AspNetUsersUncheckedUpdateInput>
  }

  /**
   * AspNetUsers delete
   */
  export type AspNetUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter which AspNetUsers to delete.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers deleteMany
   */
  export type AspNetUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUsers to delete
     */
    where?: AspNetUsersWhereInput
  }

  /**
   * AspNetUsers.AspNetUserClaims
   */
  export type AspNetUsers$AspNetUserClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    where?: AspNetUserClaimsWhereInput
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    cursor?: AspNetUserClaimsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUsers.AspNetUserLogins
   */
  export type AspNetUsers$AspNetUserLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    where?: AspNetUserLoginsWhereInput
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    cursor?: AspNetUserLoginsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUsers.AspNetUserRoles
   */
  export type AspNetUsers$AspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    where?: AspNetUserRolesWhereInput
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    cursor?: AspNetUserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUsers.AspNetUserTokens
   */
  export type AspNetUsers$AspNetUserTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    where?: AspNetUserTokensWhereInput
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    cursor?: AspNetUserTokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUsers.Posts
   */
  export type AspNetUsers$PostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Posts
     */
    select?: PostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostsInclude<ExtArgs> | null
    where?: PostsWhereInput
    orderBy?: PostsOrderByWithRelationInput | PostsOrderByWithRelationInput[]
    cursor?: PostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * AspNetUsers without action
   */
  export type AspNetUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
  }


  /**
   * Model EFMigrationsHistory
   */

  export type AggregateEFMigrationsHistory = {
    _count: EFMigrationsHistoryCountAggregateOutputType | null
    _min: EFMigrationsHistoryMinAggregateOutputType | null
    _max: EFMigrationsHistoryMaxAggregateOutputType | null
  }

  export type EFMigrationsHistoryMinAggregateOutputType = {
    MigrationId: string | null
    ProductVersion: string | null
  }

  export type EFMigrationsHistoryMaxAggregateOutputType = {
    MigrationId: string | null
    ProductVersion: string | null
  }

  export type EFMigrationsHistoryCountAggregateOutputType = {
    MigrationId: number
    ProductVersion: number
    _all: number
  }


  export type EFMigrationsHistoryMinAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
  }

  export type EFMigrationsHistoryMaxAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
  }

  export type EFMigrationsHistoryCountAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
    _all?: true
  }

  export type EFMigrationsHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFMigrationsHistory to aggregate.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EFMigrationsHistories
    **/
    _count?: true | EFMigrationsHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EFMigrationsHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EFMigrationsHistoryMaxAggregateInputType
  }

  export type GetEFMigrationsHistoryAggregateType<T extends EFMigrationsHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEFMigrationsHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEFMigrationsHistory[P]>
      : GetScalarType<T[P], AggregateEFMigrationsHistory[P]>
  }




  export type EFMigrationsHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EFMigrationsHistoryWhereInput
    orderBy?: EFMigrationsHistoryOrderByWithAggregationInput | EFMigrationsHistoryOrderByWithAggregationInput[]
    by: EFMigrationsHistoryScalarFieldEnum[] | EFMigrationsHistoryScalarFieldEnum
    having?: EFMigrationsHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EFMigrationsHistoryCountAggregateInputType | true
    _min?: EFMigrationsHistoryMinAggregateInputType
    _max?: EFMigrationsHistoryMaxAggregateInputType
  }

  export type EFMigrationsHistoryGroupByOutputType = {
    MigrationId: string
    ProductVersion: string
    _count: EFMigrationsHistoryCountAggregateOutputType | null
    _min: EFMigrationsHistoryMinAggregateOutputType | null
    _max: EFMigrationsHistoryMaxAggregateOutputType | null
  }

  type GetEFMigrationsHistoryGroupByPayload<T extends EFMigrationsHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EFMigrationsHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EFMigrationsHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EFMigrationsHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], EFMigrationsHistoryGroupByOutputType[P]>
        }
      >
    >


  export type EFMigrationsHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MigrationId?: boolean
    ProductVersion?: boolean
  }, ExtArgs["result"]["eFMigrationsHistory"]>

  export type EFMigrationsHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MigrationId?: boolean
    ProductVersion?: boolean
  }, ExtArgs["result"]["eFMigrationsHistory"]>

  export type EFMigrationsHistorySelectScalar = {
    MigrationId?: boolean
    ProductVersion?: boolean
  }


  export type $EFMigrationsHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EFMigrationsHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MigrationId: string
      ProductVersion: string
    }, ExtArgs["result"]["eFMigrationsHistory"]>
    composites: {}
  }

  type EFMigrationsHistoryGetPayload<S extends boolean | null | undefined | EFMigrationsHistoryDefaultArgs> = $Result.GetResult<Prisma.$EFMigrationsHistoryPayload, S>

  type EFMigrationsHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EFMigrationsHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EFMigrationsHistoryCountAggregateInputType | true
    }

  export interface EFMigrationsHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EFMigrationsHistory'], meta: { name: 'EFMigrationsHistory' } }
    /**
     * Find zero or one EFMigrationsHistory that matches the filter.
     * @param {EFMigrationsHistoryFindUniqueArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EFMigrationsHistoryFindUniqueArgs>(args: SelectSubset<T, EFMigrationsHistoryFindUniqueArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EFMigrationsHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EFMigrationsHistoryFindUniqueOrThrowArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EFMigrationsHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EFMigrationsHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindFirstArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EFMigrationsHistoryFindFirstArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindFirstArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EFMigrationsHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindFirstOrThrowArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EFMigrationsHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EFMigrationsHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EFMigrationsHistories
     * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
     * 
     * // Get first 10 EFMigrationsHistories
     * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany({ take: 10 })
     * 
     * // Only select the `MigrationId`
     * const eFMigrationsHistoryWithMigrationIdOnly = await prisma.eFMigrationsHistory.findMany({ select: { MigrationId: true } })
     * 
     */
    findMany<T extends EFMigrationsHistoryFindManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EFMigrationsHistory.
     * @param {EFMigrationsHistoryCreateArgs} args - Arguments to create a EFMigrationsHistory.
     * @example
     * // Create one EFMigrationsHistory
     * const EFMigrationsHistory = await prisma.eFMigrationsHistory.create({
     *   data: {
     *     // ... data to create a EFMigrationsHistory
     *   }
     * })
     * 
     */
    create<T extends EFMigrationsHistoryCreateArgs>(args: SelectSubset<T, EFMigrationsHistoryCreateArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EFMigrationsHistories.
     * @param {EFMigrationsHistoryCreateManyArgs} args - Arguments to create many EFMigrationsHistories.
     * @example
     * // Create many EFMigrationsHistories
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EFMigrationsHistoryCreateManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EFMigrationsHistories and returns the data saved in the database.
     * @param {EFMigrationsHistoryCreateManyAndReturnArgs} args - Arguments to create many EFMigrationsHistories.
     * @example
     * // Create many EFMigrationsHistories
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EFMigrationsHistories and only return the `MigrationId`
     * const eFMigrationsHistoryWithMigrationIdOnly = await prisma.eFMigrationsHistory.createManyAndReturn({ 
     *   select: { MigrationId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EFMigrationsHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, EFMigrationsHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EFMigrationsHistory.
     * @param {EFMigrationsHistoryDeleteArgs} args - Arguments to delete one EFMigrationsHistory.
     * @example
     * // Delete one EFMigrationsHistory
     * const EFMigrationsHistory = await prisma.eFMigrationsHistory.delete({
     *   where: {
     *     // ... filter to delete one EFMigrationsHistory
     *   }
     * })
     * 
     */
    delete<T extends EFMigrationsHistoryDeleteArgs>(args: SelectSubset<T, EFMigrationsHistoryDeleteArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EFMigrationsHistory.
     * @param {EFMigrationsHistoryUpdateArgs} args - Arguments to update one EFMigrationsHistory.
     * @example
     * // Update one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EFMigrationsHistoryUpdateArgs>(args: SelectSubset<T, EFMigrationsHistoryUpdateArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EFMigrationsHistories.
     * @param {EFMigrationsHistoryDeleteManyArgs} args - Arguments to filter EFMigrationsHistories to delete.
     * @example
     * // Delete a few EFMigrationsHistories
     * const { count } = await prisma.eFMigrationsHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EFMigrationsHistoryDeleteManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EFMigrationsHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EFMigrationsHistories
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EFMigrationsHistoryUpdateManyArgs>(args: SelectSubset<T, EFMigrationsHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EFMigrationsHistory.
     * @param {EFMigrationsHistoryUpsertArgs} args - Arguments to update or create a EFMigrationsHistory.
     * @example
     * // Update or create a EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.upsert({
     *   create: {
     *     // ... data to create a EFMigrationsHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EFMigrationsHistory we want to update
     *   }
     * })
     */
    upsert<T extends EFMigrationsHistoryUpsertArgs>(args: SelectSubset<T, EFMigrationsHistoryUpsertArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EFMigrationsHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryCountArgs} args - Arguments to filter EFMigrationsHistories to count.
     * @example
     * // Count the number of EFMigrationsHistories
     * const count = await prisma.eFMigrationsHistory.count({
     *   where: {
     *     // ... the filter for the EFMigrationsHistories we want to count
     *   }
     * })
    **/
    count<T extends EFMigrationsHistoryCountArgs>(
      args?: Subset<T, EFMigrationsHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EFMigrationsHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EFMigrationsHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EFMigrationsHistoryAggregateArgs>(args: Subset<T, EFMigrationsHistoryAggregateArgs>): Prisma.PrismaPromise<GetEFMigrationsHistoryAggregateType<T>>

    /**
     * Group by EFMigrationsHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EFMigrationsHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EFMigrationsHistoryGroupByArgs['orderBy'] }
        : { orderBy?: EFMigrationsHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EFMigrationsHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEFMigrationsHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EFMigrationsHistory model
   */
  readonly fields: EFMigrationsHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EFMigrationsHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EFMigrationsHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EFMigrationsHistory model
   */ 
  interface EFMigrationsHistoryFieldRefs {
    readonly MigrationId: FieldRef<"EFMigrationsHistory", 'String'>
    readonly ProductVersion: FieldRef<"EFMigrationsHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EFMigrationsHistory findUnique
   */
  export type EFMigrationsHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory findUniqueOrThrow
   */
  export type EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory findFirst
   */
  export type EFMigrationsHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFMigrationsHistories.
     */
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory findFirstOrThrow
   */
  export type EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFMigrationsHistories.
     */
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory findMany
   */
  export type EFMigrationsHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistories to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory create
   */
  export type EFMigrationsHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a EFMigrationsHistory.
     */
    data: XOR<EFMigrationsHistoryCreateInput, EFMigrationsHistoryUncheckedCreateInput>
  }

  /**
   * EFMigrationsHistory createMany
   */
  export type EFMigrationsHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EFMigrationsHistories.
     */
    data: EFMigrationsHistoryCreateManyInput | EFMigrationsHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EFMigrationsHistory createManyAndReturn
   */
  export type EFMigrationsHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EFMigrationsHistories.
     */
    data: EFMigrationsHistoryCreateManyInput | EFMigrationsHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EFMigrationsHistory update
   */
  export type EFMigrationsHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a EFMigrationsHistory.
     */
    data: XOR<EFMigrationsHistoryUpdateInput, EFMigrationsHistoryUncheckedUpdateInput>
    /**
     * Choose, which EFMigrationsHistory to update.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory updateMany
   */
  export type EFMigrationsHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EFMigrationsHistories.
     */
    data: XOR<EFMigrationsHistoryUpdateManyMutationInput, EFMigrationsHistoryUncheckedUpdateManyInput>
    /**
     * Filter which EFMigrationsHistories to update
     */
    where?: EFMigrationsHistoryWhereInput
  }

  /**
   * EFMigrationsHistory upsert
   */
  export type EFMigrationsHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the EFMigrationsHistory to update in case it exists.
     */
    where: EFMigrationsHistoryWhereUniqueInput
    /**
     * In case the EFMigrationsHistory found by the `where` argument doesn't exist, create a new EFMigrationsHistory with this data.
     */
    create: XOR<EFMigrationsHistoryCreateInput, EFMigrationsHistoryUncheckedCreateInput>
    /**
     * In case the EFMigrationsHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EFMigrationsHistoryUpdateInput, EFMigrationsHistoryUncheckedUpdateInput>
  }

  /**
   * EFMigrationsHistory delete
   */
  export type EFMigrationsHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Filter which EFMigrationsHistory to delete.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory deleteMany
   */
  export type EFMigrationsHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFMigrationsHistories to delete
     */
    where?: EFMigrationsHistoryWhereInput
  }

  /**
   * EFMigrationsHistory without action
   */
  export type EFMigrationsHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PostsScalarFieldEnum: {
    Id: 'Id',
    Content: 'Content',
    LikesCount: 'LikesCount',
    ViewsCount: 'ViewsCount',
    CommentsCount: 'CommentsCount',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt',
    UserId: 'UserId'
  };

  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]


  export const AspNetRoleClaimsScalarFieldEnum: {
    Id: 'Id',
    RoleId: 'RoleId',
    ClaimType: 'ClaimType',
    ClaimValue: 'ClaimValue'
  };

  export type AspNetRoleClaimsScalarFieldEnum = (typeof AspNetRoleClaimsScalarFieldEnum)[keyof typeof AspNetRoleClaimsScalarFieldEnum]


  export const AspNetRolesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    NormalizedName: 'NormalizedName',
    ConcurrencyStamp: 'ConcurrencyStamp'
  };

  export type AspNetRolesScalarFieldEnum = (typeof AspNetRolesScalarFieldEnum)[keyof typeof AspNetRolesScalarFieldEnum]


  export const AspNetUserClaimsScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    ClaimType: 'ClaimType',
    ClaimValue: 'ClaimValue'
  };

  export type AspNetUserClaimsScalarFieldEnum = (typeof AspNetUserClaimsScalarFieldEnum)[keyof typeof AspNetUserClaimsScalarFieldEnum]


  export const AspNetUserLoginsScalarFieldEnum: {
    LoginProvider: 'LoginProvider',
    ProviderKey: 'ProviderKey',
    ProviderDisplayName: 'ProviderDisplayName',
    UserId: 'UserId'
  };

  export type AspNetUserLoginsScalarFieldEnum = (typeof AspNetUserLoginsScalarFieldEnum)[keyof typeof AspNetUserLoginsScalarFieldEnum]


  export const AspNetUserRolesScalarFieldEnum: {
    UserId: 'UserId',
    RoleId: 'RoleId'
  };

  export type AspNetUserRolesScalarFieldEnum = (typeof AspNetUserRolesScalarFieldEnum)[keyof typeof AspNetUserRolesScalarFieldEnum]


  export const AspNetUserTokensScalarFieldEnum: {
    UserId: 'UserId',
    LoginProvider: 'LoginProvider',
    Name: 'Name',
    Value: 'Value'
  };

  export type AspNetUserTokensScalarFieldEnum = (typeof AspNetUserTokensScalarFieldEnum)[keyof typeof AspNetUserTokensScalarFieldEnum]


  export const AspNetUsersScalarFieldEnum: {
    Id: 'Id',
    UserName: 'UserName',
    NormalizedUserName: 'NormalizedUserName',
    Email: 'Email',
    NormalizedEmail: 'NormalizedEmail',
    EmailConfirmed: 'EmailConfirmed',
    PasswordHash: 'PasswordHash',
    SecurityStamp: 'SecurityStamp',
    ConcurrencyStamp: 'ConcurrencyStamp',
    PhoneNumber: 'PhoneNumber',
    PhoneNumberConfirmed: 'PhoneNumberConfirmed',
    TwoFactorEnabled: 'TwoFactorEnabled',
    LockoutEnd: 'LockoutEnd',
    LockoutEnabled: 'LockoutEnabled',
    AccessFailedCount: 'AccessFailedCount',
    Name: 'Name',
    Nickname: 'Nickname',
    CreatedAt: 'CreatedAt'
  };

  export type AspNetUsersScalarFieldEnum = (typeof AspNetUsersScalarFieldEnum)[keyof typeof AspNetUsersScalarFieldEnum]


  export const EFMigrationsHistoryScalarFieldEnum: {
    MigrationId: 'MigrationId',
    ProductVersion: 'ProductVersion'
  };

  export type EFMigrationsHistoryScalarFieldEnum = (typeof EFMigrationsHistoryScalarFieldEnum)[keyof typeof EFMigrationsHistoryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PostsWhereInput = {
    AND?: PostsWhereInput | PostsWhereInput[]
    OR?: PostsWhereInput[]
    NOT?: PostsWhereInput | PostsWhereInput[]
    Id?: IntFilter<"Posts"> | number
    Content?: StringFilter<"Posts"> | string
    LikesCount?: IntFilter<"Posts"> | number
    ViewsCount?: IntFilter<"Posts"> | number
    CommentsCount?: IntFilter<"Posts"> | number
    CreatedAt?: DateTimeFilter<"Posts"> | Date | string
    UpdatedAt?: DateTimeFilter<"Posts"> | Date | string
    UserId?: IntFilter<"Posts"> | number
    User?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }

  export type PostsOrderByWithRelationInput = {
    Id?: SortOrder
    Content?: SortOrder
    LikesCount?: SortOrder
    ViewsCount?: SortOrder
    CommentsCount?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    UserId?: SortOrder
    User?: AspNetUsersOrderByWithRelationInput
  }

  export type PostsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: PostsWhereInput | PostsWhereInput[]
    OR?: PostsWhereInput[]
    NOT?: PostsWhereInput | PostsWhereInput[]
    Content?: StringFilter<"Posts"> | string
    LikesCount?: IntFilter<"Posts"> | number
    ViewsCount?: IntFilter<"Posts"> | number
    CommentsCount?: IntFilter<"Posts"> | number
    CreatedAt?: DateTimeFilter<"Posts"> | Date | string
    UpdatedAt?: DateTimeFilter<"Posts"> | Date | string
    UserId?: IntFilter<"Posts"> | number
    User?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }, "Id">

  export type PostsOrderByWithAggregationInput = {
    Id?: SortOrder
    Content?: SortOrder
    LikesCount?: SortOrder
    ViewsCount?: SortOrder
    CommentsCount?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    UserId?: SortOrder
    _count?: PostsCountOrderByAggregateInput
    _avg?: PostsAvgOrderByAggregateInput
    _max?: PostsMaxOrderByAggregateInput
    _min?: PostsMinOrderByAggregateInput
    _sum?: PostsSumOrderByAggregateInput
  }

  export type PostsScalarWhereWithAggregatesInput = {
    AND?: PostsScalarWhereWithAggregatesInput | PostsScalarWhereWithAggregatesInput[]
    OR?: PostsScalarWhereWithAggregatesInput[]
    NOT?: PostsScalarWhereWithAggregatesInput | PostsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Posts"> | number
    Content?: StringWithAggregatesFilter<"Posts"> | string
    LikesCount?: IntWithAggregatesFilter<"Posts"> | number
    ViewsCount?: IntWithAggregatesFilter<"Posts"> | number
    CommentsCount?: IntWithAggregatesFilter<"Posts"> | number
    CreatedAt?: DateTimeWithAggregatesFilter<"Posts"> | Date | string
    UpdatedAt?: DateTimeWithAggregatesFilter<"Posts"> | Date | string
    UserId?: IntWithAggregatesFilter<"Posts"> | number
  }

  export type AspNetRoleClaimsWhereInput = {
    AND?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    OR?: AspNetRoleClaimsWhereInput[]
    NOT?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    Id?: IntFilter<"AspNetRoleClaims"> | number
    RoleId?: IntFilter<"AspNetRoleClaims"> | number
    ClaimType?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    AspNetRoles?: XOR<AspNetRolesRelationFilter, AspNetRolesWhereInput>
  }

  export type AspNetRoleClaimsOrderByWithRelationInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    AspNetRoles?: AspNetRolesOrderByWithRelationInput
  }

  export type AspNetRoleClaimsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    OR?: AspNetRoleClaimsWhereInput[]
    NOT?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    RoleId?: IntFilter<"AspNetRoleClaims"> | number
    ClaimType?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    AspNetRoles?: XOR<AspNetRolesRelationFilter, AspNetRolesWhereInput>
  }, "Id">

  export type AspNetRoleClaimsOrderByWithAggregationInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    _count?: AspNetRoleClaimsCountOrderByAggregateInput
    _avg?: AspNetRoleClaimsAvgOrderByAggregateInput
    _max?: AspNetRoleClaimsMaxOrderByAggregateInput
    _min?: AspNetRoleClaimsMinOrderByAggregateInput
    _sum?: AspNetRoleClaimsSumOrderByAggregateInput
  }

  export type AspNetRoleClaimsScalarWhereWithAggregatesInput = {
    AND?: AspNetRoleClaimsScalarWhereWithAggregatesInput | AspNetRoleClaimsScalarWhereWithAggregatesInput[]
    OR?: AspNetRoleClaimsScalarWhereWithAggregatesInput[]
    NOT?: AspNetRoleClaimsScalarWhereWithAggregatesInput | AspNetRoleClaimsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AspNetRoleClaims"> | number
    RoleId?: IntWithAggregatesFilter<"AspNetRoleClaims"> | number
    ClaimType?: StringNullableWithAggregatesFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableWithAggregatesFilter<"AspNetRoleClaims"> | string | null
  }

  export type AspNetRolesWhereInput = {
    AND?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    OR?: AspNetRolesWhereInput[]
    NOT?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    Id?: IntFilter<"AspNetRoles"> | number
    Name?: StringNullableFilter<"AspNetRoles"> | string | null
    NormalizedName?: StringNullableFilter<"AspNetRoles"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetRoles"> | string | null
    AspNetRoleClaims?: AspNetRoleClaimsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
  }

  export type AspNetRolesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    NormalizedName?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    AspNetRoleClaims?: AspNetRoleClaimsOrderByRelationAggregateInput
    AspNetUserRoles?: AspNetUserRolesOrderByRelationAggregateInput
  }

  export type AspNetRolesWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    NormalizedName?: string
    AND?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    OR?: AspNetRolesWhereInput[]
    NOT?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    Name?: StringNullableFilter<"AspNetRoles"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetRoles"> | string | null
    AspNetRoleClaims?: AspNetRoleClaimsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
  }, "Id" | "NormalizedName">

  export type AspNetRolesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    NormalizedName?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    _count?: AspNetRolesCountOrderByAggregateInput
    _avg?: AspNetRolesAvgOrderByAggregateInput
    _max?: AspNetRolesMaxOrderByAggregateInput
    _min?: AspNetRolesMinOrderByAggregateInput
    _sum?: AspNetRolesSumOrderByAggregateInput
  }

  export type AspNetRolesScalarWhereWithAggregatesInput = {
    AND?: AspNetRolesScalarWhereWithAggregatesInput | AspNetRolesScalarWhereWithAggregatesInput[]
    OR?: AspNetRolesScalarWhereWithAggregatesInput[]
    NOT?: AspNetRolesScalarWhereWithAggregatesInput | AspNetRolesScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AspNetRoles"> | number
    Name?: StringNullableWithAggregatesFilter<"AspNetRoles"> | string | null
    NormalizedName?: StringNullableWithAggregatesFilter<"AspNetRoles"> | string | null
    ConcurrencyStamp?: StringNullableWithAggregatesFilter<"AspNetRoles"> | string | null
  }

  export type AspNetUserClaimsWhereInput = {
    AND?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    OR?: AspNetUserClaimsWhereInput[]
    NOT?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    Id?: IntFilter<"AspNetUserClaims"> | number
    UserId?: IntFilter<"AspNetUserClaims"> | number
    ClaimType?: StringNullableFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetUserClaims"> | string | null
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserClaimsOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserClaimsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    OR?: AspNetUserClaimsWhereInput[]
    NOT?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    UserId?: IntFilter<"AspNetUserClaims"> | number
    ClaimType?: StringNullableFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetUserClaims"> | string | null
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }, "Id">

  export type AspNetUserClaimsOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    _count?: AspNetUserClaimsCountOrderByAggregateInput
    _avg?: AspNetUserClaimsAvgOrderByAggregateInput
    _max?: AspNetUserClaimsMaxOrderByAggregateInput
    _min?: AspNetUserClaimsMinOrderByAggregateInput
    _sum?: AspNetUserClaimsSumOrderByAggregateInput
  }

  export type AspNetUserClaimsScalarWhereWithAggregatesInput = {
    AND?: AspNetUserClaimsScalarWhereWithAggregatesInput | AspNetUserClaimsScalarWhereWithAggregatesInput[]
    OR?: AspNetUserClaimsScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserClaimsScalarWhereWithAggregatesInput | AspNetUserClaimsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AspNetUserClaims"> | number
    UserId?: IntWithAggregatesFilter<"AspNetUserClaims"> | number
    ClaimType?: StringNullableWithAggregatesFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableWithAggregatesFilter<"AspNetUserClaims"> | string | null
  }

  export type AspNetUserLoginsWhereInput = {
    AND?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    OR?: AspNetUserLoginsWhereInput[]
    NOT?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    LoginProvider?: StringFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableFilter<"AspNetUserLogins"> | string | null
    UserId?: IntFilter<"AspNetUserLogins"> | number
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserLoginsOrderByWithRelationInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrderInput | SortOrder
    UserId?: SortOrder
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserLoginsWhereUniqueInput = Prisma.AtLeast<{
    LoginProvider_ProviderKey?: AspNetUserLoginsLoginProviderProviderKeyCompoundUniqueInput
    AND?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    OR?: AspNetUserLoginsWhereInput[]
    NOT?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    LoginProvider?: StringFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableFilter<"AspNetUserLogins"> | string | null
    UserId?: IntFilter<"AspNetUserLogins"> | number
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }, "LoginProvider_ProviderKey">

  export type AspNetUserLoginsOrderByWithAggregationInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrderInput | SortOrder
    UserId?: SortOrder
    _count?: AspNetUserLoginsCountOrderByAggregateInput
    _avg?: AspNetUserLoginsAvgOrderByAggregateInput
    _max?: AspNetUserLoginsMaxOrderByAggregateInput
    _min?: AspNetUserLoginsMinOrderByAggregateInput
    _sum?: AspNetUserLoginsSumOrderByAggregateInput
  }

  export type AspNetUserLoginsScalarWhereWithAggregatesInput = {
    AND?: AspNetUserLoginsScalarWhereWithAggregatesInput | AspNetUserLoginsScalarWhereWithAggregatesInput[]
    OR?: AspNetUserLoginsScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserLoginsScalarWhereWithAggregatesInput | AspNetUserLoginsScalarWhereWithAggregatesInput[]
    LoginProvider?: StringWithAggregatesFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringWithAggregatesFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableWithAggregatesFilter<"AspNetUserLogins"> | string | null
    UserId?: IntWithAggregatesFilter<"AspNetUserLogins"> | number
  }

  export type AspNetUserRolesWhereInput = {
    AND?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    OR?: AspNetUserRolesWhereInput[]
    NOT?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    UserId?: IntFilter<"AspNetUserRoles"> | number
    RoleId?: IntFilter<"AspNetUserRoles"> | number
    AspNetRoles?: XOR<AspNetRolesRelationFilter, AspNetRolesWhereInput>
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserRolesOrderByWithRelationInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    AspNetRoles?: AspNetRolesOrderByWithRelationInput
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserRolesWhereUniqueInput = Prisma.AtLeast<{
    UserId_RoleId?: AspNetUserRolesUserIdRoleIdCompoundUniqueInput
    AND?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    OR?: AspNetUserRolesWhereInput[]
    NOT?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    UserId?: IntFilter<"AspNetUserRoles"> | number
    RoleId?: IntFilter<"AspNetUserRoles"> | number
    AspNetRoles?: XOR<AspNetRolesRelationFilter, AspNetRolesWhereInput>
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }, "UserId_RoleId">

  export type AspNetUserRolesOrderByWithAggregationInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    _count?: AspNetUserRolesCountOrderByAggregateInput
    _avg?: AspNetUserRolesAvgOrderByAggregateInput
    _max?: AspNetUserRolesMaxOrderByAggregateInput
    _min?: AspNetUserRolesMinOrderByAggregateInput
    _sum?: AspNetUserRolesSumOrderByAggregateInput
  }

  export type AspNetUserRolesScalarWhereWithAggregatesInput = {
    AND?: AspNetUserRolesScalarWhereWithAggregatesInput | AspNetUserRolesScalarWhereWithAggregatesInput[]
    OR?: AspNetUserRolesScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserRolesScalarWhereWithAggregatesInput | AspNetUserRolesScalarWhereWithAggregatesInput[]
    UserId?: IntWithAggregatesFilter<"AspNetUserRoles"> | number
    RoleId?: IntWithAggregatesFilter<"AspNetUserRoles"> | number
  }

  export type AspNetUserTokensWhereInput = {
    AND?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    OR?: AspNetUserTokensWhereInput[]
    NOT?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    UserId?: IntFilter<"AspNetUserTokens"> | number
    LoginProvider?: StringFilter<"AspNetUserTokens"> | string
    Name?: StringFilter<"AspNetUserTokens"> | string
    Value?: StringNullableFilter<"AspNetUserTokens"> | string | null
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserTokensOrderByWithRelationInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrderInput | SortOrder
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserTokensWhereUniqueInput = Prisma.AtLeast<{
    UserId_LoginProvider_Name?: AspNetUserTokensUserIdLoginProviderNameCompoundUniqueInput
    AND?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    OR?: AspNetUserTokensWhereInput[]
    NOT?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    UserId?: IntFilter<"AspNetUserTokens"> | number
    LoginProvider?: StringFilter<"AspNetUserTokens"> | string
    Name?: StringFilter<"AspNetUserTokens"> | string
    Value?: StringNullableFilter<"AspNetUserTokens"> | string | null
    AspNetUsers?: XOR<AspNetUsersRelationFilter, AspNetUsersWhereInput>
  }, "UserId_LoginProvider_Name">

  export type AspNetUserTokensOrderByWithAggregationInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrderInput | SortOrder
    _count?: AspNetUserTokensCountOrderByAggregateInput
    _avg?: AspNetUserTokensAvgOrderByAggregateInput
    _max?: AspNetUserTokensMaxOrderByAggregateInput
    _min?: AspNetUserTokensMinOrderByAggregateInput
    _sum?: AspNetUserTokensSumOrderByAggregateInput
  }

  export type AspNetUserTokensScalarWhereWithAggregatesInput = {
    AND?: AspNetUserTokensScalarWhereWithAggregatesInput | AspNetUserTokensScalarWhereWithAggregatesInput[]
    OR?: AspNetUserTokensScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserTokensScalarWhereWithAggregatesInput | AspNetUserTokensScalarWhereWithAggregatesInput[]
    UserId?: IntWithAggregatesFilter<"AspNetUserTokens"> | number
    LoginProvider?: StringWithAggregatesFilter<"AspNetUserTokens"> | string
    Name?: StringWithAggregatesFilter<"AspNetUserTokens"> | string
    Value?: StringNullableWithAggregatesFilter<"AspNetUserTokens"> | string | null
  }

  export type AspNetUsersWhereInput = {
    AND?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    OR?: AspNetUsersWhereInput[]
    NOT?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    Id?: IntFilter<"AspNetUsers"> | number
    UserName?: StringNullableFilter<"AspNetUsers"> | string | null
    NormalizedUserName?: StringNullableFilter<"AspNetUsers"> | string | null
    Email?: StringNullableFilter<"AspNetUsers"> | string | null
    NormalizedEmail?: StringNullableFilter<"AspNetUsers"> | string | null
    EmailConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    PasswordHash?: StringNullableFilter<"AspNetUsers"> | string | null
    SecurityStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumber?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumberConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    TwoFactorEnabled?: BoolFilter<"AspNetUsers"> | boolean
    LockoutEnd?: DateTimeNullableFilter<"AspNetUsers"> | Date | string | null
    LockoutEnabled?: BoolFilter<"AspNetUsers"> | boolean
    AccessFailedCount?: IntFilter<"AspNetUsers"> | number
    Name?: StringFilter<"AspNetUsers"> | string
    Nickname?: StringFilter<"AspNetUsers"> | string
    CreatedAt?: DateTimeFilter<"AspNetUsers"> | Date | string
    AspNetUserClaims?: AspNetUserClaimsListRelationFilter
    AspNetUserLogins?: AspNetUserLoginsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
    AspNetUserTokens?: AspNetUserTokensListRelationFilter
    Posts?: PostsListRelationFilter
  }

  export type AspNetUsersOrderByWithRelationInput = {
    Id?: SortOrder
    UserName?: SortOrderInput | SortOrder
    NormalizedUserName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    NormalizedEmail?: SortOrderInput | SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    SecurityStamp?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrderInput | SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    Name?: SortOrder
    Nickname?: SortOrder
    CreatedAt?: SortOrder
    AspNetUserClaims?: AspNetUserClaimsOrderByRelationAggregateInput
    AspNetUserLogins?: AspNetUserLoginsOrderByRelationAggregateInput
    AspNetUserRoles?: AspNetUserRolesOrderByRelationAggregateInput
    AspNetUserTokens?: AspNetUserTokensOrderByRelationAggregateInput
    Posts?: PostsOrderByRelationAggregateInput
  }

  export type AspNetUsersWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    NormalizedUserName?: string
    AND?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    OR?: AspNetUsersWhereInput[]
    NOT?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    UserName?: StringNullableFilter<"AspNetUsers"> | string | null
    Email?: StringNullableFilter<"AspNetUsers"> | string | null
    NormalizedEmail?: StringNullableFilter<"AspNetUsers"> | string | null
    EmailConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    PasswordHash?: StringNullableFilter<"AspNetUsers"> | string | null
    SecurityStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumber?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumberConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    TwoFactorEnabled?: BoolFilter<"AspNetUsers"> | boolean
    LockoutEnd?: DateTimeNullableFilter<"AspNetUsers"> | Date | string | null
    LockoutEnabled?: BoolFilter<"AspNetUsers"> | boolean
    AccessFailedCount?: IntFilter<"AspNetUsers"> | number
    Name?: StringFilter<"AspNetUsers"> | string
    Nickname?: StringFilter<"AspNetUsers"> | string
    CreatedAt?: DateTimeFilter<"AspNetUsers"> | Date | string
    AspNetUserClaims?: AspNetUserClaimsListRelationFilter
    AspNetUserLogins?: AspNetUserLoginsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
    AspNetUserTokens?: AspNetUserTokensListRelationFilter
    Posts?: PostsListRelationFilter
  }, "Id" | "NormalizedUserName">

  export type AspNetUsersOrderByWithAggregationInput = {
    Id?: SortOrder
    UserName?: SortOrderInput | SortOrder
    NormalizedUserName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    NormalizedEmail?: SortOrderInput | SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    SecurityStamp?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrderInput | SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    Name?: SortOrder
    Nickname?: SortOrder
    CreatedAt?: SortOrder
    _count?: AspNetUsersCountOrderByAggregateInput
    _avg?: AspNetUsersAvgOrderByAggregateInput
    _max?: AspNetUsersMaxOrderByAggregateInput
    _min?: AspNetUsersMinOrderByAggregateInput
    _sum?: AspNetUsersSumOrderByAggregateInput
  }

  export type AspNetUsersScalarWhereWithAggregatesInput = {
    AND?: AspNetUsersScalarWhereWithAggregatesInput | AspNetUsersScalarWhereWithAggregatesInput[]
    OR?: AspNetUsersScalarWhereWithAggregatesInput[]
    NOT?: AspNetUsersScalarWhereWithAggregatesInput | AspNetUsersScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AspNetUsers"> | number
    UserName?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    NormalizedUserName?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    Email?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    NormalizedEmail?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    EmailConfirmed?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    PasswordHash?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    SecurityStamp?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    ConcurrencyStamp?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    PhoneNumberConfirmed?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    TwoFactorEnabled?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    LockoutEnd?: DateTimeNullableWithAggregatesFilter<"AspNetUsers"> | Date | string | null
    LockoutEnabled?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    AccessFailedCount?: IntWithAggregatesFilter<"AspNetUsers"> | number
    Name?: StringWithAggregatesFilter<"AspNetUsers"> | string
    Nickname?: StringWithAggregatesFilter<"AspNetUsers"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"AspNetUsers"> | Date | string
  }

  export type EFMigrationsHistoryWhereInput = {
    AND?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    OR?: EFMigrationsHistoryWhereInput[]
    NOT?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    MigrationId?: StringFilter<"EFMigrationsHistory"> | string
    ProductVersion?: StringFilter<"EFMigrationsHistory"> | string
  }

  export type EFMigrationsHistoryOrderByWithRelationInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryWhereUniqueInput = Prisma.AtLeast<{
    MigrationId?: string
    AND?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    OR?: EFMigrationsHistoryWhereInput[]
    NOT?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    ProductVersion?: StringFilter<"EFMigrationsHistory"> | string
  }, "MigrationId">

  export type EFMigrationsHistoryOrderByWithAggregationInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
    _count?: EFMigrationsHistoryCountOrderByAggregateInput
    _max?: EFMigrationsHistoryMaxOrderByAggregateInput
    _min?: EFMigrationsHistoryMinOrderByAggregateInput
  }

  export type EFMigrationsHistoryScalarWhereWithAggregatesInput = {
    AND?: EFMigrationsHistoryScalarWhereWithAggregatesInput | EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    OR?: EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    NOT?: EFMigrationsHistoryScalarWhereWithAggregatesInput | EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    MigrationId?: StringWithAggregatesFilter<"EFMigrationsHistory"> | string
    ProductVersion?: StringWithAggregatesFilter<"EFMigrationsHistory"> | string
  }

  export type PostsCreateInput = {
    Content: string
    LikesCount?: number
    ViewsCount?: number
    CommentsCount?: number
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    User: AspNetUsersCreateNestedOneWithoutPostsInput
  }

  export type PostsUncheckedCreateInput = {
    Id?: number
    Content: string
    LikesCount?: number
    ViewsCount?: number
    CommentsCount?: number
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    UserId: number
  }

  export type PostsUpdateInput = {
    Content?: StringFieldUpdateOperationsInput | string
    LikesCount?: IntFieldUpdateOperationsInput | number
    ViewsCount?: IntFieldUpdateOperationsInput | number
    CommentsCount?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: AspNetUsersUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Content?: StringFieldUpdateOperationsInput | string
    LikesCount?: IntFieldUpdateOperationsInput | number
    ViewsCount?: IntFieldUpdateOperationsInput | number
    CommentsCount?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type PostsCreateManyInput = {
    Id?: number
    Content: string
    LikesCount?: number
    ViewsCount?: number
    CommentsCount?: number
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
    UserId: number
  }

  export type PostsUpdateManyMutationInput = {
    Content?: StringFieldUpdateOperationsInput | string
    LikesCount?: IntFieldUpdateOperationsInput | number
    ViewsCount?: IntFieldUpdateOperationsInput | number
    CommentsCount?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Content?: StringFieldUpdateOperationsInput | string
    LikesCount?: IntFieldUpdateOperationsInput | number
    ViewsCount?: IntFieldUpdateOperationsInput | number
    CommentsCount?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetRoleClaimsCreateInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
    AspNetRoles: AspNetRolesCreateNestedOneWithoutAspNetRoleClaimsInput
  }

  export type AspNetRoleClaimsUncheckedCreateInput = {
    Id?: number
    RoleId: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsUpdateInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoles?: AspNetRolesUpdateOneRequiredWithoutAspNetRoleClaimsNestedInput
  }

  export type AspNetRoleClaimsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RoleId?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsCreateManyInput = {
    Id?: number
    RoleId: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsUpdateManyMutationInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RoleId?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRolesCreateInput = {
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsCreateNestedManyWithoutAspNetRolesInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUncheckedCreateInput = {
    Id?: number
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedCreateNestedManyWithoutAspNetRolesInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUpdateManyWithoutAspNetRolesNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesCreateManyInput = {
    Id?: number
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
  }

  export type AspNetRolesUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRolesUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsCreateInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserClaimsInput
  }

  export type AspNetUserClaimsUncheckedCreateInput = {
    Id?: number
    UserId: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsUpdateInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserClaimsNestedInput
  }

  export type AspNetUserClaimsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsCreateManyInput = {
    Id?: number
    UserId: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsUpdateManyMutationInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsCreateInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserLoginsInput
  }

  export type AspNetUserLoginsUncheckedCreateInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    UserId: number
  }

  export type AspNetUserLoginsUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserLoginsNestedInput
  }

  export type AspNetUserLoginsUncheckedUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserLoginsCreateManyInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    UserId: number
  }

  export type AspNetUserLoginsUpdateManyMutationInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUncheckedUpdateManyInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserRolesCreateInput = {
    AspNetRoles: AspNetRolesCreateNestedOneWithoutAspNetUserRolesInput
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserRolesInput
  }

  export type AspNetUserRolesUncheckedCreateInput = {
    UserId: number
    RoleId: number
  }

  export type AspNetUserRolesUpdateInput = {
    AspNetRoles?: AspNetRolesUpdateOneRequiredWithoutAspNetUserRolesNestedInput
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserRolesNestedInput
  }

  export type AspNetUserRolesUncheckedUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    RoleId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserRolesCreateManyInput = {
    UserId: number
    RoleId: number
  }

  export type AspNetUserRolesUpdateManyMutationInput = {

  }

  export type AspNetUserRolesUncheckedUpdateManyInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    RoleId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserTokensCreateInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserTokensInput
  }

  export type AspNetUserTokensUncheckedCreateInput = {
    UserId: number
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserTokensNestedInput
  }

  export type AspNetUserTokensUncheckedUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensCreateManyInput = {
    UserId: number
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensUpdateManyMutationInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensUncheckedUpdateManyInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUsersCreateInput = {
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersUncheckedCreateInput = {
    Id?: number
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsUncheckedCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersUpdateInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersCreateManyInput = {
    Id?: number
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
  }

  export type AspNetUsersUpdateManyMutationInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AspNetUsersUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EFMigrationsHistoryCreateInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUncheckedCreateInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUpdateInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryUncheckedUpdateInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryCreateManyInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUpdateManyMutationInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryUncheckedUpdateManyInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AspNetUsersRelationFilter = {
    is?: AspNetUsersWhereInput
    isNot?: AspNetUsersWhereInput
  }

  export type PostsCountOrderByAggregateInput = {
    Id?: SortOrder
    Content?: SortOrder
    LikesCount?: SortOrder
    ViewsCount?: SortOrder
    CommentsCount?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    UserId?: SortOrder
  }

  export type PostsAvgOrderByAggregateInput = {
    Id?: SortOrder
    LikesCount?: SortOrder
    ViewsCount?: SortOrder
    CommentsCount?: SortOrder
    UserId?: SortOrder
  }

  export type PostsMaxOrderByAggregateInput = {
    Id?: SortOrder
    Content?: SortOrder
    LikesCount?: SortOrder
    ViewsCount?: SortOrder
    CommentsCount?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    UserId?: SortOrder
  }

  export type PostsMinOrderByAggregateInput = {
    Id?: SortOrder
    Content?: SortOrder
    LikesCount?: SortOrder
    ViewsCount?: SortOrder
    CommentsCount?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    UserId?: SortOrder
  }

  export type PostsSumOrderByAggregateInput = {
    Id?: SortOrder
    LikesCount?: SortOrder
    ViewsCount?: SortOrder
    CommentsCount?: SortOrder
    UserId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AspNetRolesRelationFilter = {
    is?: AspNetRolesWhereInput
    isNot?: AspNetRolesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AspNetRoleClaimsCountOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetRoleClaimsAvgOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetRoleClaimsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetRoleClaimsMinOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetRoleClaimsSumOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AspNetRoleClaimsListRelationFilter = {
    every?: AspNetRoleClaimsWhereInput
    some?: AspNetRoleClaimsWhereInput
    none?: AspNetRoleClaimsWhereInput
  }

  export type AspNetUserRolesListRelationFilter = {
    every?: AspNetUserRolesWhereInput
    some?: AspNetUserRolesWhereInput
    none?: AspNetUserRolesWhereInput
  }

  export type AspNetRoleClaimsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUserRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetRolesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AspNetRolesAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AspNetRolesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AspNetRolesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AspNetRolesSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AspNetUserClaimsCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetUserClaimsAvgOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserClaimsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetUserClaimsMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetUserClaimsSumOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserLoginsLoginProviderProviderKeyCompoundUniqueInput = {
    LoginProvider: string
    ProviderKey: string
  }

  export type AspNetUserLoginsCountOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserLoginsAvgOrderByAggregateInput = {
    UserId?: SortOrder
  }

  export type AspNetUserLoginsMaxOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserLoginsMinOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserLoginsSumOrderByAggregateInput = {
    UserId?: SortOrder
  }

  export type AspNetUserRolesUserIdRoleIdCompoundUniqueInput = {
    UserId: number
    RoleId: number
  }

  export type AspNetUserRolesCountOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetUserRolesAvgOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetUserRolesMaxOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetUserRolesMinOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetUserRolesSumOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetUserTokensUserIdLoginProviderNameCompoundUniqueInput = {
    UserId: number
    LoginProvider: string
    Name: string
  }

  export type AspNetUserTokensCountOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type AspNetUserTokensAvgOrderByAggregateInput = {
    UserId?: SortOrder
  }

  export type AspNetUserTokensMaxOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type AspNetUserTokensMinOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type AspNetUserTokensSumOrderByAggregateInput = {
    UserId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AspNetUserClaimsListRelationFilter = {
    every?: AspNetUserClaimsWhereInput
    some?: AspNetUserClaimsWhereInput
    none?: AspNetUserClaimsWhereInput
  }

  export type AspNetUserLoginsListRelationFilter = {
    every?: AspNetUserLoginsWhereInput
    some?: AspNetUserLoginsWhereInput
    none?: AspNetUserLoginsWhereInput
  }

  export type AspNetUserTokensListRelationFilter = {
    every?: AspNetUserTokensWhereInput
    some?: AspNetUserTokensWhereInput
    none?: AspNetUserTokensWhereInput
  }

  export type PostsListRelationFilter = {
    every?: PostsWhereInput
    some?: PostsWhereInput
    none?: PostsWhereInput
  }

  export type AspNetUserClaimsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUserLoginsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUserTokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUsersCountOrderByAggregateInput = {
    Id?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    Name?: SortOrder
    Nickname?: SortOrder
    CreatedAt?: SortOrder
  }

  export type AspNetUsersAvgOrderByAggregateInput = {
    Id?: SortOrder
    AccessFailedCount?: SortOrder
  }

  export type AspNetUsersMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    Name?: SortOrder
    Nickname?: SortOrder
    CreatedAt?: SortOrder
  }

  export type AspNetUsersMinOrderByAggregateInput = {
    Id?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    Name?: SortOrder
    Nickname?: SortOrder
    CreatedAt?: SortOrder
  }

  export type AspNetUsersSumOrderByAggregateInput = {
    Id?: SortOrder
    AccessFailedCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EFMigrationsHistoryCountOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryMaxOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryMinOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type AspNetUsersCreateNestedOneWithoutPostsInput = {
    create?: XOR<AspNetUsersCreateWithoutPostsInput, AspNetUsersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutPostsInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AspNetUsersUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutPostsInput, AspNetUsersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutPostsInput
    upsert?: AspNetUsersUpsertWithoutPostsInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutPostsInput, AspNetUsersUpdateWithoutPostsInput>, AspNetUsersUncheckedUpdateWithoutPostsInput>
  }

  export type AspNetRolesCreateNestedOneWithoutAspNetRoleClaimsInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetRoleClaimsInput
    connect?: AspNetRolesWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AspNetRolesUpdateOneRequiredWithoutAspNetRoleClaimsNestedInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetRoleClaimsInput
    upsert?: AspNetRolesUpsertWithoutAspNetRoleClaimsInput
    connect?: AspNetRolesWhereUniqueInput
    update?: XOR<XOR<AspNetRolesUpdateToOneWithWhereWithoutAspNetRoleClaimsInput, AspNetRolesUpdateWithoutAspNetRoleClaimsInput>, AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput>
  }

  export type AspNetRoleClaimsCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
  }

  export type AspNetUserRolesCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetRoleClaimsUncheckedCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
  }

  export type AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetRoleClaimsUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    set?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    disconnect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    delete?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    update?: AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput | AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
  }

  export type AspNetUserRolesUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    set?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    disconnect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    delete?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    update?: AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput | AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserClaimsInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserClaimsInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserClaimsNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserClaimsInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserClaimsInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserClaimsInput, AspNetUsersUpdateWithoutAspNetUserClaimsInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput>
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserLoginsInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserLoginsInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserLoginsNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserLoginsInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserLoginsInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserLoginsInput, AspNetUsersUpdateWithoutAspNetUserLoginsInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput>
  }

  export type AspNetRolesCreateNestedOneWithoutAspNetUserRolesInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetUserRolesInput
    connect?: AspNetRolesWhereUniqueInput
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserRolesInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserRolesInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetRolesUpdateOneRequiredWithoutAspNetUserRolesNestedInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetUserRolesInput
    upsert?: AspNetRolesUpsertWithoutAspNetUserRolesInput
    connect?: AspNetRolesWhereUniqueInput
    update?: XOR<XOR<AspNetRolesUpdateToOneWithWhereWithoutAspNetUserRolesInput, AspNetRolesUpdateWithoutAspNetUserRolesInput>, AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserRolesNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserRolesInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserRolesInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserRolesInput, AspNetUsersUpdateWithoutAspNetUserRolesInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserTokensInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserTokensInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserTokensNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserTokensInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserTokensInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserTokensInput, AspNetUsersUpdateWithoutAspNetUserTokensInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput>
  }

  export type AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
  }

  export type AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
  }

  export type AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
  }

  export type PostsCreateNestedManyWithoutUserInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
  }

  export type AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
  }

  export type AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
  }

  export type AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
  }

  export type PostsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    disconnect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    delete?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    update?: AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
  }

  export type AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    disconnect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    delete?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    update?: AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
  }

  export type AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    disconnect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    delete?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    update?: AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
  }

  export type PostsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    upsert?: PostsUpsertWithWhereUniqueWithoutUserInput | PostsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    set?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    disconnect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    delete?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    update?: PostsUpdateWithWhereUniqueWithoutUserInput | PostsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostsUpdateManyWithWhereWithoutUserInput | PostsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostsScalarWhereInput | PostsScalarWhereInput[]
  }

  export type AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    disconnect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    delete?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    update?: AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
  }

  export type AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    disconnect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    delete?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    update?: AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    disconnect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    delete?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    update?: AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
  }

  export type PostsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput> | PostsCreateWithoutUserInput[] | PostsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostsCreateOrConnectWithoutUserInput | PostsCreateOrConnectWithoutUserInput[]
    upsert?: PostsUpsertWithWhereUniqueWithoutUserInput | PostsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostsCreateManyUserInputEnvelope
    set?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    disconnect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    delete?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    connect?: PostsWhereUniqueInput | PostsWhereUniqueInput[]
    update?: PostsUpdateWithWhereUniqueWithoutUserInput | PostsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostsUpdateManyWithWhereWithoutUserInput | PostsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostsScalarWhereInput | PostsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AspNetUsersCreateWithoutPostsInput = {
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersUncheckedCreateWithoutPostsInput = {
    Id?: number
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersCreateOrConnectWithoutPostsInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutPostsInput, AspNetUsersUncheckedCreateWithoutPostsInput>
  }

  export type AspNetUsersUpsertWithoutPostsInput = {
    update: XOR<AspNetUsersUpdateWithoutPostsInput, AspNetUsersUncheckedUpdateWithoutPostsInput>
    create: XOR<AspNetUsersCreateWithoutPostsInput, AspNetUsersUncheckedCreateWithoutPostsInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutPostsInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutPostsInput, AspNetUsersUncheckedUpdateWithoutPostsInput>
  }

  export type AspNetUsersUpdateWithoutPostsInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutPostsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetRolesCreateWithoutAspNetRoleClaimsInput = {
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput = {
    Id?: number
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesCreateOrConnectWithoutAspNetRoleClaimsInput = {
    where: AspNetRolesWhereUniqueInput
    create: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
  }

  export type AspNetRolesUpsertWithoutAspNetRoleClaimsInput = {
    update: XOR<AspNetRolesUpdateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput>
    create: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
    where?: AspNetRolesWhereInput
  }

  export type AspNetRolesUpdateToOneWithWhereWithoutAspNetRoleClaimsInput = {
    where?: AspNetRolesWhereInput
    data: XOR<AspNetRolesUpdateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput>
  }

  export type AspNetRolesUpdateWithoutAspNetRoleClaimsInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRoleClaimsCreateWithoutAspNetRolesInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsWhereUniqueInput
    create: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope = {
    data: AspNetRoleClaimsCreateManyAspNetRolesInput | AspNetRoleClaimsCreateManyAspNetRolesInput[]
    skipDuplicates?: boolean
  }

  export type AspNetUserRolesCreateWithoutAspNetRolesInput = {
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserRolesInput
  }

  export type AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput = {
    UserId: number
  }

  export type AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput = {
    where: AspNetUserRolesWhereUniqueInput
    create: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesCreateManyAspNetRolesInputEnvelope = {
    data: AspNetUserRolesCreateManyAspNetRolesInput | AspNetUserRolesCreateManyAspNetRolesInput[]
    skipDuplicates?: boolean
  }

  export type AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsWhereUniqueInput
    update: XOR<AspNetRoleClaimsUpdateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedUpdateWithoutAspNetRolesInput>
    create: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsWhereUniqueInput
    data: XOR<AspNetRoleClaimsUpdateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedUpdateWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsScalarWhereInput
    data: XOR<AspNetRoleClaimsUpdateManyMutationInput, AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsScalarWhereInput = {
    AND?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
    OR?: AspNetRoleClaimsScalarWhereInput[]
    NOT?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
    Id?: IntFilter<"AspNetRoleClaims"> | number
    RoleId?: IntFilter<"AspNetRoleClaims"> | number
    ClaimType?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetRoleClaims"> | string | null
  }

  export type AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetUserRolesWhereUniqueInput
    update: XOR<AspNetUserRolesUpdateWithoutAspNetRolesInput, AspNetUserRolesUncheckedUpdateWithoutAspNetRolesInput>
    create: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetUserRolesWhereUniqueInput
    data: XOR<AspNetUserRolesUpdateWithoutAspNetRolesInput, AspNetUserRolesUncheckedUpdateWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput = {
    where: AspNetUserRolesScalarWhereInput
    data: XOR<AspNetUserRolesUpdateManyMutationInput, AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesScalarWhereInput = {
    AND?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
    OR?: AspNetUserRolesScalarWhereInput[]
    NOT?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
    UserId?: IntFilter<"AspNetUserRoles"> | number
    RoleId?: IntFilter<"AspNetUserRoles"> | number
  }

  export type AspNetUsersCreateWithoutAspNetUserClaimsInput = {
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput = {
    Id?: number
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsUncheckedCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserClaimsInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
  }

  export type AspNetUsersUpsertWithoutAspNetUserClaimsInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserClaimsInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserClaimsInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersCreateWithoutAspNetUserLoginsInput = {
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput = {
    Id?: number
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsUncheckedCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserLoginsInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
  }

  export type AspNetUsersUpsertWithoutAspNetUserLoginsInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserLoginsInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserLoginsInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AspNetRolesCreateWithoutAspNetUserRolesInput = {
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput = {
    Id?: number
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesCreateOrConnectWithoutAspNetUserRolesInput = {
    where: AspNetRolesWhereUniqueInput
    create: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
  }

  export type AspNetUsersCreateWithoutAspNetUserRolesInput = {
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput = {
    Id?: number
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsUncheckedCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserRolesInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
  }

  export type AspNetRolesUpsertWithoutAspNetUserRolesInput = {
    update: XOR<AspNetRolesUpdateWithoutAspNetUserRolesInput, AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput>
    create: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
    where?: AspNetRolesWhereInput
  }

  export type AspNetRolesUpdateToOneWithWhereWithoutAspNetUserRolesInput = {
    where?: AspNetRolesWhereInput
    data: XOR<AspNetRolesUpdateWithoutAspNetUserRolesInput, AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetRolesUpdateWithoutAspNetUserRolesInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetUsersUpsertWithoutAspNetUserRolesInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserRolesInput, AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserRolesInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserRolesInput, AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserRolesInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersCreateWithoutAspNetUserTokensInput = {
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput = {
    Id?: number
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    Name?: string
    Nickname?: string
    CreatedAt?: Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    Posts?: PostsUncheckedCreateNestedManyWithoutUserInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserTokensInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
  }

  export type AspNetUsersUpsertWithoutAspNetUserTokensInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserTokensInput, AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserTokensInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserTokensInput, AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserTokensInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUpdateManyWithoutUserNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Nickname?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    Posts?: PostsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AspNetUserClaimsCreateWithoutAspNetUsersInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserClaimsWhereUniqueInput
    create: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserClaimsCreateManyAspNetUsersInput | AspNetUserClaimsCreateManyAspNetUsersInput[]
    skipDuplicates?: boolean
  }

  export type AspNetUserLoginsCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserLoginsWhereUniqueInput
    create: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserLoginsCreateManyAspNetUsersInput | AspNetUserLoginsCreateManyAspNetUsersInput[]
    skipDuplicates?: boolean
  }

  export type AspNetUserRolesCreateWithoutAspNetUsersInput = {
    AspNetRoles: AspNetRolesCreateNestedOneWithoutAspNetUserRolesInput
  }

  export type AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput = {
    RoleId: number
  }

  export type AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserRolesWhereUniqueInput
    create: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserRolesCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserRolesCreateManyAspNetUsersInput | AspNetUserRolesCreateManyAspNetUsersInput[]
    skipDuplicates?: boolean
  }

  export type AspNetUserTokensCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserTokensWhereUniqueInput
    create: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserTokensCreateManyAspNetUsersInput | AspNetUserTokensCreateManyAspNetUsersInput[]
    skipDuplicates?: boolean
  }

  export type PostsCreateWithoutUserInput = {
    Content: string
    LikesCount?: number
    ViewsCount?: number
    CommentsCount?: number
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type PostsUncheckedCreateWithoutUserInput = {
    Id?: number
    Content: string
    LikesCount?: number
    ViewsCount?: number
    CommentsCount?: number
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type PostsCreateOrConnectWithoutUserInput = {
    where: PostsWhereUniqueInput
    create: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput>
  }

  export type PostsCreateManyUserInputEnvelope = {
    data: PostsCreateManyUserInput | PostsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserClaimsWhereUniqueInput
    update: XOR<AspNetUserClaimsUpdateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserClaimsWhereUniqueInput
    data: XOR<AspNetUserClaimsUpdateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserClaimsScalarWhereInput
    data: XOR<AspNetUserClaimsUpdateManyMutationInput, AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsScalarWhereInput = {
    AND?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
    OR?: AspNetUserClaimsScalarWhereInput[]
    NOT?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
    Id?: IntFilter<"AspNetUserClaims"> | number
    UserId?: IntFilter<"AspNetUserClaims"> | number
    ClaimType?: StringNullableFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetUserClaims"> | string | null
  }

  export type AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserLoginsWhereUniqueInput
    update: XOR<AspNetUserLoginsUpdateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserLoginsWhereUniqueInput
    data: XOR<AspNetUserLoginsUpdateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserLoginsScalarWhereInput
    data: XOR<AspNetUserLoginsUpdateManyMutationInput, AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsScalarWhereInput = {
    AND?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
    OR?: AspNetUserLoginsScalarWhereInput[]
    NOT?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
    LoginProvider?: StringFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableFilter<"AspNetUserLogins"> | string | null
    UserId?: IntFilter<"AspNetUserLogins"> | number
  }

  export type AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserRolesWhereUniqueInput
    update: XOR<AspNetUserRolesUpdateWithoutAspNetUsersInput, AspNetUserRolesUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserRolesWhereUniqueInput
    data: XOR<AspNetUserRolesUpdateWithoutAspNetUsersInput, AspNetUserRolesUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserRolesScalarWhereInput
    data: XOR<AspNetUserRolesUpdateManyMutationInput, AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserTokensWhereUniqueInput
    update: XOR<AspNetUserTokensUpdateWithoutAspNetUsersInput, AspNetUserTokensUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserTokensWhereUniqueInput
    data: XOR<AspNetUserTokensUpdateWithoutAspNetUsersInput, AspNetUserTokensUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserTokensScalarWhereInput
    data: XOR<AspNetUserTokensUpdateManyMutationInput, AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensScalarWhereInput = {
    AND?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
    OR?: AspNetUserTokensScalarWhereInput[]
    NOT?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
    UserId?: IntFilter<"AspNetUserTokens"> | number
    LoginProvider?: StringFilter<"AspNetUserTokens"> | string
    Name?: StringFilter<"AspNetUserTokens"> | string
    Value?: StringNullableFilter<"AspNetUserTokens"> | string | null
  }

  export type PostsUpsertWithWhereUniqueWithoutUserInput = {
    where: PostsWhereUniqueInput
    update: XOR<PostsUpdateWithoutUserInput, PostsUncheckedUpdateWithoutUserInput>
    create: XOR<PostsCreateWithoutUserInput, PostsUncheckedCreateWithoutUserInput>
  }

  export type PostsUpdateWithWhereUniqueWithoutUserInput = {
    where: PostsWhereUniqueInput
    data: XOR<PostsUpdateWithoutUserInput, PostsUncheckedUpdateWithoutUserInput>
  }

  export type PostsUpdateManyWithWhereWithoutUserInput = {
    where: PostsScalarWhereInput
    data: XOR<PostsUpdateManyMutationInput, PostsUncheckedUpdateManyWithoutUserInput>
  }

  export type PostsScalarWhereInput = {
    AND?: PostsScalarWhereInput | PostsScalarWhereInput[]
    OR?: PostsScalarWhereInput[]
    NOT?: PostsScalarWhereInput | PostsScalarWhereInput[]
    Id?: IntFilter<"Posts"> | number
    Content?: StringFilter<"Posts"> | string
    LikesCount?: IntFilter<"Posts"> | number
    ViewsCount?: IntFilter<"Posts"> | number
    CommentsCount?: IntFilter<"Posts"> | number
    CreatedAt?: DateTimeFilter<"Posts"> | Date | string
    UpdatedAt?: DateTimeFilter<"Posts"> | Date | string
    UserId?: IntFilter<"Posts"> | number
  }

  export type AspNetRoleClaimsCreateManyAspNetRolesInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserRolesCreateManyAspNetRolesInput = {
    UserId: number
  }

  export type AspNetRoleClaimsUpdateWithoutAspNetRolesInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsUncheckedUpdateWithoutAspNetRolesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserRolesUpdateWithoutAspNetRolesInput = {
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserRolesNestedInput
  }

  export type AspNetUserRolesUncheckedUpdateWithoutAspNetRolesInput = {
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesInput = {
    UserId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserClaimsCreateManyAspNetUsersInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserLoginsCreateManyAspNetUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type AspNetUserRolesCreateManyAspNetUsersInput = {
    RoleId: number
  }

  export type AspNetUserTokensCreateManyAspNetUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type PostsCreateManyUserInput = {
    Id?: number
    Content: string
    LikesCount?: number
    ViewsCount?: number
    CommentsCount?: number
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type AspNetUserClaimsUpdateWithoutAspNetUsersInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsUncheckedUpdateWithoutAspNetUsersInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUncheckedUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserRolesUpdateWithoutAspNetUsersInput = {
    AspNetRoles?: AspNetRolesUpdateOneRequiredWithoutAspNetUserRolesNestedInput
  }

  export type AspNetUserRolesUncheckedUpdateWithoutAspNetUsersInput = {
    RoleId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersInput = {
    RoleId?: IntFieldUpdateOperationsInput | number
  }

  export type AspNetUserTokensUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensUncheckedUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostsUpdateWithoutUserInput = {
    Content?: StringFieldUpdateOperationsInput | string
    LikesCount?: IntFieldUpdateOperationsInput | number
    ViewsCount?: IntFieldUpdateOperationsInput | number
    CommentsCount?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsUncheckedUpdateWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Content?: StringFieldUpdateOperationsInput | string
    LikesCount?: IntFieldUpdateOperationsInput | number
    ViewsCount?: IntFieldUpdateOperationsInput | number
    CommentsCount?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostsUncheckedUpdateManyWithoutUserInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Content?: StringFieldUpdateOperationsInput | string
    LikesCount?: IntFieldUpdateOperationsInput | number
    ViewsCount?: IntFieldUpdateOperationsInput | number
    CommentsCount?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AspNetRolesCountOutputTypeDefaultArgs instead
     */
    export type AspNetRolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetRolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetUsersCountOutputTypeDefaultArgs instead
     */
    export type AspNetUsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetUsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostsDefaultArgs instead
     */
    export type PostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetRoleClaimsDefaultArgs instead
     */
    export type AspNetRoleClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetRoleClaimsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetRolesDefaultArgs instead
     */
    export type AspNetRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetRolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetUserClaimsDefaultArgs instead
     */
    export type AspNetUserClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetUserClaimsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetUserLoginsDefaultArgs instead
     */
    export type AspNetUserLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetUserLoginsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetUserRolesDefaultArgs instead
     */
    export type AspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetUserRolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetUserTokensDefaultArgs instead
     */
    export type AspNetUserTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetUserTokensDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AspNetUsersDefaultArgs instead
     */
    export type AspNetUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AspNetUsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EFMigrationsHistoryDefaultArgs instead
     */
    export type EFMigrationsHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EFMigrationsHistoryDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}